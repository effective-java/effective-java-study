# 15장 입출력 I/O

## Java에서의 입출력

`입출력` : 컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고받는 것

### 스트림(stream)

**`스트림(stream)`** : Java에서 입출력을 수행할 때, 어느 한쪽에서 다른 쪽으로 데이터를 전달할 때 필요한 두 대상을 연결하고 데이터를 전송할 수 있는 것
- **데이터를 옮기는데 사용되는 연결통로**
- 14장에 나왔던 스트림과는 용어는 같지만 다른 개념

stream은 연속적인 데이터의 흐름이 물과 같아서 붙여진 이름, 여러가지 유사한 점이 많다.
- 물이 한쪽 방향으로 흐르는 것과 같이 stream은 **단방향통신**만 가능하기 때문에 **하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다.**
- 입력과 출력을 동시에 수행하려면 **입력을 위한 입력스트림(input stream), 출력을 위한 출력스트림(output stream), 모두 2개의 스트림**이 필요하다.
- stream은 먼저 보낸 데이터를 먼저 받게 되어 있으며 **중간에 건너뜀 없이 연속적으로 데이터를 주고 받는다.**
- **Queue와 같은 FIFO구조**

![Java애플리케이션과 파일간의 입출력](https://user-images.githubusercontent.com/56071088/133897770-3c42a1bd-97eb-47ad-b684-0100033a2a7c.png)


### Byte기반 스트림 - InputStream, OutputStream

stream은 **Byte단위**로 data를 전송하며 입출력 대상에 따라 입출력스트림이 각각에 맞게 존재한다.
- Byte기반이라 함은 **입출력의 단위가 1 byte**라는 뜻 
- 대상에 맞게, 용도에 맞게 해당 스트림을 선택해서 사용하면 된다.
- 이들은 **모두 InputStream 또는 OutputStream의 자손들, 각각 읽고 쓰는데 필요한 추상메서드(abstract method)를 자신에 맞게 구현해 놓았다.**

**[입출력스트림의 종류]**

|입력스트림|출력스트림|입출력 대상의 종류|
|---|---|---|
|FileInputStream|FileOutputStream|파일|
|ByteArrayInputStream|ByteArrayOutputStream|메모리(byte배열)|
|PipedInputStream|PipedOutputStream|프로세스(프로세스간의 통신)|
|AudioInputStream|AudioOutputStream|오디오장치|

Java에서는 `java.io패키지`를 통해서 많은 종류의 입출력 관련 클래스들을 제공한다.
- 입출력을 처리할 수 있는 표준화된 방법을 제공함으로써 입출력의 대상이 달라져도 동일한 방법으로 입출력이 가능하기 때문에 programming하기 편리하다.

**[InputStream과 OutputStream에 정의된 읽기와 쓰기를 수행하는 메서드]**

|InputStream|OutputStream|
|---|---|
|abstract int read()|abstract void write(int b)|
|int read(byte[] b)|void write(byte[] b)|
|int read(byte[] b, int off, int len)|void write(byte[] b, int off, int len)|

[참고] **read()의 반환 타입이 byte가 아니라 int인 이유는 read()의 반환값의 범위가 0~255와 -1이기 때문이다.**

- read()와 write(int b)를 제외하고, 나머지는 추상 메서드들이 아니기 때문에, 굳이 구현해서 사용하지 않고, 나머지 메서드들을 사용하면 된다고 생각할 수 있다.
  - **하지만, 나머지 메서드들이 이 2개의 추상메서드들을 사용하여 구현되어진 것들이기 때문에, read(), write(int b)가 구현되어 있지 않으면, 나머지 메서드들은 아무런 의미가 없다.**


**[InputStream의 실제 코드의 일부를 이해하기 쉽게 약간 변형한 메서드]**

```java
public abstract class InputStream {
    ...
    // 입력스트림으로부터 1 byte를 읽어서 반환한다. 읽을 수 없으면 -1을 반환.
    abstract int read();

    // 위 표의 3번째 메서드, 추상 메서드인 abstract int read()를 사용하는 것을 볼 수 있다.
    // 입력스트림으로부터 length개의 byte를 읽어서 byte배열 b의 off위치부터 저장한다.
    int read(byte[] b, int off, int length) {
        ...
        for(int i = off; i < off + length; ++i) {
            // read()를 호출해서 데이터를 읽어서 배열을 채운다.
            b[i] = (byte)read();
        }
    }

    ...

    // 바로 위의 메서드를 사용하고 있다.
    // 입력스트림으로부터 byte배열 b의 크기만큼 데이터를 읽어서 배열 b에 저장한다.
    int read(byte[] b) {
        return read(b, 0, b.length);
    } 

    ...
}
```

- **메서드는 선언부만 알고 있어도 호출이 가능**하기 때문에, **추상 메서드를 호출하는 코드를 작성**할 수 있다.
- 실제로는 **추상클래스를 상속 받아서 추상메서드를 구현한 클래스의 인스턴스**에 대해서 **추상메서드가 호출되는 것**이기 때문에 **추상메서드를 호출하는 코드를 작성**해도 **아무런 문제가 되지 않는다.**

결론적으로, read()를 반드시 구현되어야하는 핵심적인 메서드이고, read()없이는 나머지 2개의 메서드들은 의미가 없다.

### 보조 스트림

**`보조 스트림`** : **stream의 기능을 보완하기 위해 보조스트림이 제공된다.**
- 보조 스트림은 **실제 데이터를 주고 받지는 않는다.**
  - 따라서, 데이터를 입출력하는 기능은 없다.
- **스트림의 기능을 향상시키거나 새로운 기능을 추가하는 역할**
  - **보조스트림만으로는 입출력을 처리할 수 없고, 스트림을 먼저 생성한 다음에 이를 이용해서 보조스트림을 생성해야 한다.**

**[파일을 읽기 위해 FileInputStream을 사용할 때, 입력 성능을 향상시키기 위한 Buffer를 사용한느 보조스트림인 BufferedInputStream을 사용하는 예시]**

```java
// 먼저 기반스트림을 생성한다.
FileInputStream fis = new FileInputStream("test.txt");

// 기반 스트림을 이용해서 보조스트림을 생성한다.
BufferedInputStream bis = new BufferedInputStream(fis);

// 보조스트림인 BufferedInputStream으로부터 데이터를 읽는다.
bis.read();
```

- 실제 입력 기능은 BufferedInputStream과 연결된 FileInputStream이 수행한다. 
- 보조스트림인 BufferedInputStream은 Buffer만을 제공한다.
- Buffer를 사용한 입출력과 사용하지 않은 입출력간의 성능차이는 상당하기 때문에 대부분 Buffer를 이용한 보조스트림을 사용한다.

**[보조스트림의 종류]**

|입력|출력|설명|
|---|---|---|
|FilterInputStream|FilterOutputStream|**Filter를 이용한 입출력 처리**|
|BufferedInputStream|BufferedOutputStream|**Buffer를 이용한 입출력 성능 향상**|
|DataInputStream|DataOutputStream|**int, float와 같은 기본형 단위(primitive type)로 데이터를 처리하는 기능**|
|SequenceInputStream|없음|**2개의 스트림을 하나로 연결**|
|LineNumberInputStream|없음|**읽어 온 Data의 라인 번호를 카운트(JDK 1.1부터 LineNumberReader으로 대체)**|
|ObjectInputStream|ObjectOutputStream|**data를 객체 단위로 읽고 쓴는데 사용. 주로 File을 이용하여 객체 직렬화와 관련이 있음.**|
|없음|PrintStream|**Buffer를 이용하며, 추가적인 print관련 기능(print, printf, println메서드)**|
|PushbackInputStream|없음|**Buffer를 이용해서 읽어 온 Data를 다시 되돌리는 기능(unread, push back to buffer)**|

- BufferedInputStream, DataInputStream, LineNumberInputStream, PushbackInputStream은 모두 FilterInputStream의 자식이다.
- **FilterInputStream은 InputStream의 자식이다.**
- 따라서, **모든 보조스트림 역시 InputStream, OutputStream의 자식이다.**

### 문자기반 스트림 - Reader, Writer

**Java에서는 한 문자를 의미하는 char형이 1 byte가 아니라 2 byte이기 때문에 Byte기반의 스트림으로 2 Byte인 문자를 처리하는데 어려움이 있다.**
- 이러한 점을 보완하기 위해 **문자 기반의 스트림**이 제공된다.
- **문자 데이터를 입출력할 때**는 **문자 기반의 스트림**을 사용하자.

```json
InputStream -> Reader
OutputStream -> Writer
```

**[바이트기반 스트림과 문자기반 스트림의 비교]**

|바이트기반스트림|문자기반스트림|
|---|---|
|FileInputStream, FileOutputStream|FileReader, FileWriter|
|ByteArrayInputStream, ByteArrayOutputStream|CharArrayReader, CharArrayWriter|
|PipedInputStream, PipedOutputStream|PipedReader, PipedWriter|
|(deprecated)|StringReader, StringWriter|

[참고] StringBufferInputStream, StringBufferOutputStream은 StringReader, StringWriter로 대체되어 더 이상 사용되지 않는다.

**[Byte기반 스트림과 char기반 스트림의 읽기와 쓰기에 사용되는 메서드 비교]**

|InputStream|Reader|
|---|---|
|abstract int read()|int read()|
|int read(byte[] b)|int read(char[] cbuf)|
|int read(byte[] b, int off, int len)|abstract int read(char[] cbuf, int off, int len)|

|OutputStream|Writer|
|---|---|
|abstract void write(byte[] b)|void write(int c)|
|void write(byte[] b)|void write(char[] cbuf)|
|void write(byte[] b, int off, int len)|abstract void write(char[] cbuf, int off, int len)|
||void write(String Str)|
||void write(String Str, int off, int len)|

- Reader, Writer역시 추상 메서드가 아닌 메서드들은 추상 메서드를 이용해서 작성되었다.
- 프로그래밍 관점에서 볼 때, read()를 추상 메서드로 하는 것 보다 int read(char[] cbuf, int off, int len)를 추상 메서드로 하는 것이 더 바람직하다.

**[Byte기반 보조스트림, Char기반 보조 스트림]**

|Byte기반 보조스트림|Char기반 보조 스트림|
|---|---|
|BufferedInputStream, BufferdOutputStream|BufferedReader, BufferedWriter|
|FilterInputStream, FilterOutputStream|FilterReader, FilterWriter|
|LineNumberInputStream(deprecated)|LineNumberReader|
|PrintStream|PrintWriter|
|PushbackInputStream|PushbackReader|

## Byte기반 스트림

### InputStream, OutputStream

**[InputStream의 메서드]**

![InputStream의 메서드](https://user-images.githubusercontent.com/56071088/133924527-74d2af90-4fd0-4490-966e-f65ef416ccc1.png)

**[OutputStream의 메서드]**

![OutputStream의 메서드](https://user-images.githubusercontent.com/56071088/133924525-90be782a-2a9b-42a3-8ba4-7f24a68acbae.png)

- **`mark(), reset()`** : 이미 읽은 데이터를 되돌려서 읽을 수 있다. (stream의 종류에 따라서 다르다.)
- **`markSupported()`** : mark(), reset()을 지원하는 스트림인지 확인하는 메서드
- **`flush()`** : Buffer가 있는 출력스트림의 경우에만 의미가 있다.
  - OutputStream에 정의된 flush()는 아무런 일도 하지 않는다.
- **`close()`** : stream을 사용해서 모든 작업을 마치고 난 후에는 close()를 호출해서 반드시 stream을 닫아 주어야 한다.
  - program이 종료될 때, 사용하고 닫지 않은 스트림을 JVM이 자동적으로 닫아 주기는 한다.
  - **ByteArrayInputStream과 같이 메모리를 사용하는 스트림**과 **System.in, System.out과 같은 표준 입출력 스트림**은 **닫아 주지 않아도 된다.**

### ByteArrayInputStream, ByteArrayOutputStream

**`ByteArrayInputStream/ByteArrayOutputStream`** : Memory, 즉 ByteArray에 data를 입출력 하는데 사용되는 stream이다.
- 주로 다른 곳에 입출력하기 전에 data를 임시로 ByteArray에 담아서 변환 등의 작업을 하는데 사용된다.
- 자주 사용되지는 않는다.
  
**스트림의 종류가 달라도 읽고 쓰는 방법은 동일하다.**

**[ByteArrayInputStream, ByteArrayOutputStream을 이용해서 Byte배열 inSrc의 Data를 outSrc로 복사하는 예제]**
- read(), write()를 사용하는 가장 기본적인 방법을 보여준다.
- ByteArray는 **사용하는 자원이 Memory**밖에 없으므로 **Garbage Collector에 의해 자동적으로 자원을 반환**하므로 **close()를 이용해서 스트림을 닫지 않아도 된다.**
- read(), write(int b)를 사용하기 때문에 **한 번에 1 Byte만 읽고 쓰므로 작업의 효율성이 떨어진다.**

```java
(data = input.read()) != -1 
1. data = input.read() // read()를 호출한 반환값을 변수 data에 저장한다. () 괄호 먼저
2. data != -1 // data에 저장된 값이 -1이 아닌지 비교한다.
```

```java
import java.io.*;
import java.util.Arrays;

class IOEx1 {
	public static void main(String[] args) {
		byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
		byte[] outSrc = null;

		ByteArrayInputStream  input  = null;
		ByteArrayOutputStream output = null;

		input  = new ByteArrayInputStream(inSrc);
		output = new ByteArrayOutputStream();

		int data = 0;

		while((data = input.read())!=-1) {
			output.write(data);	// void write(int b)
		}

		outSrc = output.toByteArray(); // 스트림의 내용을 byte배열로 반환한다.

		System.out.println("Input Source  :" + Arrays.toString(inSrc));
		System.out.println("Output Source :" + Arrays.toString(outSrc));
	}
}
```

```json
실행결과
Input Source : [0,1,2,3,4,5,6,7,8,9]
Output Source : [0,1,2,3,4,5,6,7,8,9]
```

**[int read(byte[] b, int off, int len), void write(byte[] b, int off, int len)를 사용해서 입출력하는 방법을 보여주는 예제]**

- 하나씩 입력받고, 출력하는 것이 아닌, **byte배열(예제에서 temp)** 를 이용하여 한번에 배열의 크기만큼 읽고 쓸수 있다.
- **배열의 이용한 입출력은 작업의 효율을 증가**시키므로 가능하면 **입출력 대상에 따라 알맞은 크기의 배열을 사용**하는 것이 좋다.

```java
input.read(temp, 0, temp.length); // 읽어 온 데이터를 배열 temp에 담는다.
output.write(temp, 5, 5); // temp[5] 부터 5개의 data를 write한다.
```

```java
import java.io.*;
import java.util.Arrays;

class IOEx3 {
	public static void main(String[] args) {
		byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
		byte[] outSrc = null;

		byte[] temp = new byte[4];	// 이전 예제와 배열의 크기가 다르다.

		ByteArrayInputStream input = null;
		ByteArrayOutputStream output = null;

		input  = new ByteArrayInputStream(inSrc);
		output = new ByteArrayOutputStream();

		System.out.println("Input Source  :" + Arrays.toString(inSrc));

		try {
			while(input.available() > 0) {
				input.read(temp);
				output.write(temp); 
//				System.out.println("temp :" + Arrays.toString(temp));

				outSrc = output.toByteArray();
				printArrays(temp, outSrc);
			}
		} catch(IOException e) {}
	} // main의 끝

	static void printArrays(byte[] temp, byte[] outSrc) {
		System.out.println("temp          :" +Arrays.toString(temp));
		System.out.println("Output Source :" +Arrays.toString(outSrc));	
	}
}
```

```json
실행결과
Input Source : [0,1,2,3,4,5,6,7,8,9]

temp : [0,1,2,3]
Output Source : [0,1,2,3]

temp : [4,5,6,7]
Output Source : [0,1,2,3,4,5,6,7]

temp : [8,9,6,7]
Output Source : [0,1,2,3,4,5,6,7,8,9,6,7]
```

- read(), write()가 IOException이 발생할 수 있기 때문에 try-catch문으로 감싸주었다.
- available() : **Blocking 없이 읽어 올 수 있는 Byte의 수를 반환한다.**
  - **`Blocking`** : **Data를 읽어 올 때 data를 기다리기 위해 멈춰있는 것**을 뜻한다.
  - EX) 사용자가 data를 입력할 때 까지 기다리고 있을 때 Blocking상태라고 한다.
마지막 결과가 temp에 남아있던 6,7 까지 전부 출력했다.
- **보다 나은 성능을 위해서** temp에 담긴 내용을 지우고 쓰는 것이 아니라 **그냥 기존의 내용 위에 덮어 쓴다.**
- 그래서 temp의 내용이 `[4,5,6,7]` 이었는데, 8,9를 읽고 난 후에는 `[8,9,6,7]`이 된다.

**[이전 예제의 문제점을 수정한 예제]**
- 출력할 때 temp에 저장된 모든 내용을 출력하는 대신 **값을 읽어온 만큼만 출력하도록 변경하였다.**

```java
while(input.available() > 0) {
    input.read(temp);
    output.write(temp);
}

--> 

while(input.available() > 0) {
    int len = input.read(temp); // 읽어 온 데이터의 개수를 반환한다.
    output.write(temp, 0, len); // 읽어 온 만큼만 write한다.
}
```

```java
import java.io.*;
import java.util.Arrays;	

class IOEx4 {
	public static void main(String[] args) {
		byte[] inSrc = {0,1,2,3,4,5,6,7,8,9};
		byte[] outSrc = null;

		byte[] temp = new byte[4];

		ByteArrayInputStream  input  = null;
		ByteArrayOutputStream output = null;

		input  = new ByteArrayInputStream(inSrc);
		output = new ByteArrayOutputStream();

		try {
			while(input.available() > 0) {
				int len = input.read(temp); // 읽어 온 데이터의 개수를 반환한다.
				output.write(temp, 0, len); // 읽어 온 만큼만 write한다.
			}
		} catch(IOException e) {}

		outSrc = output.toByteArray();

		System.out.println("Input Source  :" + Arrays.toString(inSrc));
		System.out.println("temp          :" + Arrays.toString(temp));
		System.out.println("Output Source :" + Arrays.toString(outSrc));
	}
}
```

```json
실행결과
Input Source : [0,1,2,3,4,5,6,7,8,9]
temp : [8,9,6,7]
Output Source : [0,1,2,3,4,5,6,7,8,9]
```

### FileInputStream, FileOutputStream

**`FileInputStream, FileOutputStream`** : **File에 입출력을 하기 위한 스트림**
- 실제 Programming에서 많이 사용되는 stream중의 하나

![FileInputStream, FileOutputStream](https://user-images.githubusercontent.com/56071088/133933771-82ddf3c6-d652-4a46-8ae2-11f4afcd2054.png)


**[FileInputStream, FileOutputStream을 사용해서 FileCopy.java 파일의 내뇽을 그대로 FileCopy.bak으로 복사하는 예제]**

```java
import java.io.*;

class FileCopy {
	public static void main(String args[]) {
		try {
			FileInputStream  fis = new FileInputStream(args[0]);
			FileOutputStream fos = new FileOutputStream(args[1]);

			int data =0;
			while((data=fis.read())!=-1) {
				fos.write(data);	 // void write(int b)
			}

			fis.close();
			fos.close();
		} catch (IOException e) {
			e.printStackTrace();		
		}
	}
}
```

```java
C:\jdk1.8\work\ch15>java FileCopy FileCopy.java FileCopy.bak

C:\jdk1.8\work\ch15>type FileCopy.bak
import java.io.*;

class FileCopy {
	public static void main(String args[]) {
		try {
			FileInputStream  fis = new FileInputStream(args[0]);
			FileOutputStream fos = new FileOutputStream(args[1]);

			int data =0;
			while((data=fis.read())!=-1) {
				fos.write(data);	 // void write(int b)
			}

			fis.close();
			fos.close();
		} catch (IOException e) {
			e.printStackTrace();		
		}
	}
}

C:\jdk1.8\work\ch15>
```

- **read()** 가 **한번에 1 byte씩 File로 부터 읽어** 들이긴 하지만, **data의 범위가 십진수로 0~255 (16진수로는 0x00~0xff) 범위의 정수값**이고, 
- 또 **읽을 수 있는 입력값이 더 이상 없음**을 알릴 수 있는 **값(-1)도 필요**하다. 
- 그래서 다소 크긴 하지만 정수형 중에서는 연산이 가장 효율적이고 빠른 int형 값을 반환하도록 한 것

단순히 FileCopy.java의 내용을 읽어서, read()로 읽어서 write(int b)로 FileCopy.bak에 출력한다.
- 이처럼 Text파일을 다루는 경우에는 FileInputStream/FileOutputStream보다 문자기반(char기반)stream인 FileReader/FileWriter를 사용하는 것이 더 좋다.

[참고] 
- 기존의 File에 새로운 내용을 추가하려면,
-  FileOutputStream fos = new FileOutputStream(args[1], true); 
-  위와 같이 생성자의 2번째 매개변수의 값을 true로 해야 한다.

![FileInputStream, FileOutputStream을 이용한 파일복사 drawio](https://user-images.githubusercontent.com/56071088/133935369-292736e5-361e-4986-adfa-263499eb66dd.png)


## Byte기반의 보조스트림

### FilterInputStream, FilterOutputStream

**`FilterInputStream, FilterOutputStream`** : **InputStream, OutputStream의 자손, 모든 보조스트림의 조상**
- **보조스트림은 자체적으로 입출력을 수행할 수 없기 때문에 기반스트림을 필요로 한다.**

**[FilterInputStream, FilterOutputStream의 생성자]**

```java
protected FilterInputStream(InputStream in)
public FilterOutputStream(OutputStream out)
```

- FilterInputStream, FilterOutputStream의 모든 메서드는 단순히 기반 stream의 메서드를 그대로 호출할 뿐이다.
- FilterInputStream, FilterOutputStream 자체로는 아무런 일도 하지 않는다.

**[FilterInputStream class]**

```java
public class FilterInputStream extends InputStream {
    protected volatile InputStream in;

    protected FilterInputstraem(InputStream in) {
        this.in = in;
    }

    public int read() throws IOException {
        return in.read();
    }
}
```

- **FilterInputStream, FilterOutputStream은 상속을 통해 원하는 작업을 수행하도록 Overriding해야 한다.**
- `생성자 protected FilterInputStream(InputStream in)` 는 접근제어자가 `protected`이기 때문에 FilterInputStream의 인스턴스를 생성해서 사용할 수 없고 상속을 통해서 Overriding되어야 한다.

**[FilterInputStream, FilterOutputStream을 상속 받아서 기반스트림에 보조기능을 추가한 보조스트림 클래스]**

```java
FilterInputStream의 자손 : BufferedInputStream, DataInputStream, PushbackInputStream 등
FilterOutputStream의 자손 : BufferedOutputStream, DataOutputStream, PrintStream 등 
```

### BufferedInputStream, BufferedOutputStream

**`BufferedInputStream, BufferedOutputStream`** : 스트림의 **입출력 효율**을 높이기 위해 **Buffer를 사용**하는 **보조스트림**이다.
- 1 Byte씩 입출력하는 것 보다는 **Buffer(Byte 배열)** 을 이용해서 **한 번에 여러 바이트를 입출력**하는 것이 빠르기 때문에 **대부분의 입출력에 사용된다.** 

**[BufferedInputStream의 생성자]**

|생성자|설명|
|---|---|
|BufferedInputStream(Inputstream in, int size)|주어진 InputStream인스턴스를 입력소스(Input Source)로 하며, 지정된 크기(Byte 단위) 의 Buffer를 갖는 BufferedInputStream인스턴스를 생성한다.|
|BufferedInputStream(Inputstream in)|주어진 InputStream인스턴스를 입력소스(input source)로 하며, Buffer의 크기를 지정해주지 않으므로 기본적으로 8192 Byte크기의 Buffer를 갖게 된다.|

- Buffer의 크기는 입력소스(Input Source)로부터 한 번에 가져올 수 있는 Data의 크기로 지정하면 좋다.
  - 보통 입력소스(Input Source)가 File인 경우, 4096 정도의 크기로 하는 것이 보통이다.
- Program에서 입력소스(Input Source)로부터 Data를 읽기 위해 **처음으로 read메서드를 호출**하면, BufferedInputStream은 Buffer크기 만큼의 Data를 읽어서 **자신의 내부 Buffer에 저장한다.**
  - 이제 Program에서는 BufferedInputStream의 Buffer에 저장된 Data를 읽으면 되는 것
  - **외부의 Input Source로 부터 Data를 읽는 것보다 내부의 Buffer로 부터 읽는 것이 훨씬 빠르기 때문에 그만큼 작업의 효율이 높아진다.**
- Program에서 Buffer에 저장된 모든 Data를 다 읽고 그 다음 Data를 읽기위해 read() 가 호출되면, 입력소스로부터 다시 Buffer크기 만큼의 Data를 읽어서 Buffer에 저장해 놓는다. 
  - 이와 같은 작업을 계속해서 반복한다.

**[BufferedOutputStream의 생성자와 메서드]**

![BufferedOutputStream의 생성자와 메서드](https://user-images.githubusercontent.com/56071088/133937702-da6a2bab-8773-4b04-8bc5-d084a9d1c55c.png)

- Buffer를 이용해서 출력소스(Output Source)와 작업을 한다.
- Program에서 write()를 이용한 출력이 **BufferedOutputStream의 Buffer에 저장**된다.
- **Buffer가 가득차면, 그 때 Buffer의 모든 내용을 출력소스에 출력한다.**
  - 그리고는 Buffer를 비우고 다시 Program으로부터의 출력을 저장할 준비를 한다.
  
**Buffer가 가득 찼을 때만 출력소스에 출력**을 하기 때문에, 

**마지막 출력 부분이 출력소스에 쓰이지 못하고, BufferedOutputStream의 Buffer에 남아있는 채로 Program이 종료될 수 있다는 점을 주의**해야 한다.

- ***Program에서 모든 출력작업을 마친 후, BufferedOutputStream에 close(), flush()를 호출해서 마지막에 Buffer에 있는 모든 내뇽이 출력소스에 출력되도록 해야 한다.***

[참고] **BufferedOutputStream의 close()는 flush()를 호출하여 Buffer의 내용을 출력스트림에 쓰도록 한 후, BufferedOutputStream인스턴스의 참조변수에 null을 지정함으로써 사용하던 자원들이 반환하게 한다.**

**[FilterOutputStream의 소스코드]**

```java
public class FilterOutputStream extends OutputStream {
    protected OutputStream out;

    public FilterOutputStream(OutputStream out) {
        this.out = out;
    }

    ...

    public void close() throws IOException {
        try {
            flush();
        } catch (IOException ignored) {}
        out.close(); // 기반 스트림의 close()를 호출한다.
    }
}
```

- BufferedOutputStream 조상 ->  FilterOutputStream 조상 -> OutputStream
- **FilterOutputStream의 close() : flush()를 호출한 다음, 조상 스트림인 OutputStream의 close()를 호출한다.**
- BufferedOutputStream은 FilterOutputStream의 close()를 Overriding없이 그대로 상속받는다.

***보조 스트림을 사용하는 경우에 바로 보조 스트림의 close()를 호출하기만 하면 된다!!***

### DataInputStream, DataOutputStream

**`DataInputStream, DataOutputStream`** 
- 각각 FilterInputStream, FilterOutputStream의 자손
- DataInputStream은 DataInput인터페이스, DataOutputStream은 DataOutput인터페이스를 각각 구현했다.
- Data를 읽고 쓰는데 Byte 단위가 아닌, 8가지 Primitive type을 단위로 읽고 쓸 수 있다는 장점이 있다.

DataOutputStream이 출력하는 형식은 각 기본 자료형 값을 16진수로 표현하여 저장한다.
- EX) int(4 Byte)값을 출력한다면, 4 Byte의 16진수로 출력된다.

각 자료형의 크기가 다르므로, 출력한 Data를 다시 읽어 올 때는 출력했을 때의 순서를 염두에 두어야 한다.

**[DataInputStream의 생성자와 메서드]**

![DataInputStream의 생성자와 메서드](https://user-images.githubusercontent.com/56071088/133938535-e7ad6171-7e8f-4100-a41c-e8a258706d5f.png)

- **DataInputStream의 readInt()와 같이 Data를 읽는 메서드**는 더 이상 읽을 Data가 없으면 `EOFException`을 발생시킨다.
- 그래서 다른 입력스트림들과는 달리 **무한반복문**과 **EOFException을 처리하는 catch문을 이용해서 Data를 읽는다.**

**[DataOutputStream의 생성자와 메서드]**

![DataOutputStream의 생성자와 메서드](https://user-images.githubusercontent.com/56071088/133938536-6007ca7a-e16f-4a69-92d3-0f7cf984da92.png)

**[ByteArrayOutputStream을 기반으로 하는 DataOutputStream을 생성한 후, ByteArrayOutputStream의 메서드를 이용하여 출력하는 예제]**

```java
import java.io.*;
import java.util.Arrays;

class DataOutputStreamEx2 {
	public static void main(String args[]) {
		ByteArrayOutputStream bos = null;
		DataOutputStream      dos = null;

		byte[] result = null;

		try {
			bos = new ByteArrayOutputStream();
			dos = new DataOutputStream(bos);
			dos.writeInt(10);
			dos.writeFloat(20.0f);
			dos.writeBoolean(true);

			result = bos.toByteArray();

			String[] hex = new String[result.length];

			for(int i=0;i<result.length; i++) {
				if(result[i] < 0) { 
					hex[i] = String.format("%02x", result[i]+256);
				} else {
					hex[i] = String.format("%02x", result[i]);
				}
			}

			System.out.println("10진수  :" + Arrays.toString(result));
			System.out.println("16진수  :" + Arrays.toString(hex));

			dos.close();
		} catch (IOException e) {
			e.printStackTrace();		
		}
	} // main
}
```

```json
실행결과
10진수 : [0,0,0,10,65,-96,0,0,1]
16진수 : [00,00,00,0a,41,a0,00,00,01]
```

- writeInt(10) : 4 Byte(int) : 0,0,0,10
- writeFloat(20.0f) : 4 Byte(float) : 65,-96,0,0
- writeBoolean(true) : 1 Byte(Boolean) : 1
- 1 Byte : 8 bit
- 같은 Data이지만 Java의 자료형인 Byte의 범위가 부호 있는 1 Byte 정수의 범위인 -128~127 이기 때문에 -1로 인식하는 것이다.
- 그래서 이 값을 0~255의 값으로 변환하려면 256을 더해야 한다.
- 반대의 경우에는 256을 빼면 된다.
- 다음에 String.format() 을 사용해서 10진 정수를 16진 정수로 변환하여 출력한다.

ByteArrayInputStream,ByteArrayOutputStream을 이용하면 Byte단위의 Data 변환 및 조작이 가능하다는 것을 알아두자.

InputStream의 read()는 반환타입이 int, 0~255의 값을 반환하므로 256을 더하거나 뺄 필요가 없다.

반면에, read(byte[] b) 와 같이 byte 배열을 사용하는 경우 상황에 따라 0~255 범위의 값으로 변환해야 할 필요가 있다.

**[DataInputStream을 이용하여 sample.dat를 읽어서 화면에 출력하는 예제]**

```java
import java.io.*;

class DataOutputStreamEx1 {
	public static void main(String args[]) {
		FileOutputStream fos = null;
		DataOutputStream dos = null;

		try {
			fos = new FileOutputStream("sample.dat");
			dos = new DataOutputStream(fos);
			dos.writeInt(10);
			dos.writeFloat(20.0f);
			dos.writeBoolean(true);
				
			dos.close();
		} catch (IOException e) {
			e.printStackTrace();		
		}
	} // main
}
```

```json
실행결과
10
20.0
true
```

- Data의 Type에 맞는 메서드, 예를 들면, int 형이면 readInt() 메서드를 사용하여 읽어오면 된다.
- 문자로 Data를 저장하면, 문자열 "100"을 숫자 100으로 변환하는 과정, 읽어야 할 데이터의 개수를 고려해야 하지만
  - DataInputStream, DataOutputStream을 사용하면, Data를 변환할 필요 없고, 자리수를 세어서 따지지 않아도 되므로 편리하고 빠르게 데이터를 저장하고 읽을 수 있게 된다.

**[DataInputSteam을 이용하여 score.dat 파일을 읽어서 Data의 총합을 구하는 예제]**

```java
import java.io.*;

class DataInputStreamEx2 {
	public static void main(String args[]) {
		int sum   = 0;
		int score = 0;

		FileInputStream fis = null;
		DataInputStream dis = null;

		try {
			fis = new FileInputStream("score.dat");
			dis = new DataInputStream(fis);

			while(true) {
				score = dis.readInt();
				System.out.println(score);	
				sum += score;
			}
		} catch (EOFException e) {
			System.out.println("점수의 총합은 " + sum +"입니다.");
		} catch (IOException ie) {
			ie.printStackTrace();
		} finally {
			try {
				if(dis!=null)
					dis.close();			
			} catch(IOException ie){
				ie.printStackTrace();			
			}
		} // try
	} // main
}
```

```json
실행결과
100
90
95
85
50
점수의 총합은 420입니다.
```

- **DataInputStream의 readInt()와 같이 Data를 읽는 메서드**는 더 이상 읽을 Data가 없으면 `EOFException`을 발생시킨다.
- 그래서 다른 입력스트림들과는 달리 **무한반복문**과 **EOFException을 처리하는 catch문을 이용해서 Data를 읽는다.**

원래 while문으로 작업을 마친 후에 스트림을 닫아 줘야 하는데, while문이 무한반복문이기 때문에 **finally 블럭에서 스트림을 닫도록 처리하였다.**
- 참조 변수 dis 가 null일 때 close()를 호출하면 NullPointerException이 발생하므로
- if문을 사용해서 dis가 null인지 체크한 후에 `close()`를 호출해야 한다.
- `close()`가 `IOException`을 발생시킬 수 있으므로 `try-catch블럭`으로 감싸주었다.
- 작업 도중에 예외가 발생할 수 있기 때문에, `try문`이 아닌 **`finally블럭`** 을 이용해서 **스트림을 닫아주는 것이 더 확실한 방법이다.**

사실 Program이 종료될 때, Garbage Collector가 사용하던 자원들을 모두 해제 해주기 때문에, 간단한 예제에서는 stream을 닫지 않아도 별문제가 되지 않는다.

그래도 가능하면 stream을 사용한 직후에 바로 닫아서 자원을 반환하는 것이 좋다.


**[JDK 1.7에 추가된 try-with-resources를 이용한 방법]**
- JDK 1.7에 추가된 try-with-resources문을 이용하여 close()를 직접 호출하지 않아도 자동 호출되도록 할 수 있다.

```java
import java.io.*;

class DataInputStreamEx3 {
	public static void main(String args[]) {
		int sum   = 0;
		int score = 0;

		try (FileInputStream fis = new FileInputStream("score.dat");
		     DataInputStream dis = new DataInputStream(fis)) 
		{
			
			while(true) {
				score = dis.readInt();
				System.out.println(score);	
				sum += score;
			}
		} catch (EOFException e) {
			System.out.println("점수의 총합은 " + sum +"입니다.");
		} catch (IOException ie) {
			ie.printStackTrace();
		} // try
	} // main
}
```

- **try( FileInputStream fis = new FileInputStream("score.dat"); DataInputStream dis = new DataInputStream(fis) ) {}** 를 이용

### SequenceInputStream

**`SequenceInputStream`** : 여러 개의 입력 스트림을 연속적으로 연결해서 하나의 스트림으로부터 데이터를 읽는 것과 같이 처리할 수 있도록 도와준다.
- SequenceInputStream의 생성자를 제외하고 나머지 작업은 다른 입력 스트림과 다르지 않다.
- 큰 파일을 여러 개의 작은 파일로 나누었다가 하나의 파일로 합치는 것과 같은 작업을 수행할 때 사용하면 좋을 것이다.
- SequenceImputStream은 FilterInputStream의 자손이 아닌 InputStream을 바로 상속 받아서 구현하였다.

**[SequenceInputStream의 생성자]**

![SequenceInputStream의 생성자](https://user-images.githubusercontent.com/56071088/134021427-2d199a25-9218-4436-8e65-6437aad8a07c.png)

**Vector에 연결할 입력스트림들을 저장한 다음 Vector의 Enumeration elements() 를 호출해서 생성자의 매개변수로 사용한다.**

**[사용 예 1]**

```java
Vector files = new Vector();
files.add(new FileInputStream("file.001"));
files.add(new FileInputStream("file.002"));
SequenceInputStream in = new SequenceInputStream(files.elements());
```

**[사용 예 2]**

```java
FileInputStream file1 = new FileInputStream("file.001");
FileInputStream file2 = new FileInputStream("file.002");
SequenceInputStream in = new SequenceInputStream(file1, file2);
```

```java
import java.io.*;
import java.util.*;

class SequenceInputStreamEx {
	public static void main(String[] args) {
		byte[] arr1 = {0,1,2};
		byte[] arr2 = {3,4,5};
		byte[] arr3 = {6,7,8};
		byte[] outSrc = null;

		Vector v = new Vector();
		v.add(new ByteArrayInputStream(arr1));
		v.add(new ByteArrayInputStream(arr2));
		v.add(new ByteArrayInputStream(arr3));

		SequenceInputStream   input  = new SequenceInputStream(v.elements());
		ByteArrayOutputStream output = new ByteArrayOutputStream();

		int data = 0;

		try {
			while((data = input.read())!=-1) {
				output.write(data);	// void write(int b)
			}
		} catch(IOException e) {}

		outSrc = output.toByteArray();

		System.out.println("Input Source1  :" + Arrays.toString(arr1));
		System.out.println("Input Source2  :" + Arrays.toString(arr2));
		System.out.println("Input Source3  :" + Arrays.toString(arr3));
	    System.out.println("Output Source  :" + Arrays.toString(outSrc));
	}
}
```

```json
실행결과
Input Source1 : [0,1,2]
Input Source2 : [3,4,5]
Input Source3 : [6,7,8]
Output Source : [0,1,2,3,4,5,6,7,8]
```

- 3개의 ByteArrayInputStream을 Vector와 SequenceInputStream을 이용해서 하나의 입력스트림처럼 다룰 수 있다.
- Vector에 입력되므로 순서에 주의하도록 하자!

### PrintStream - print(), printf(), println() - 문자 기반 스트림의 역할

**`PrintStream`** 
- Data를 기반스트림에 다양한 형태로 출력할 수 있는 `print, printf, println`와 같은 메서드를 Overloading하여 제공한다.
- PrintStream은 Data를 적절한 문자로 출력하는 것이기 때문에 문자 기반 스트림의 역할을 수행한다.
- JDK 1.1부터 향상된 기능의 PrintWriter이 추가되었으나 매우 빈번히 사용되던 System.out이 PrintStream이다 보니 둘 다 사용할 수 밖에 없게 되었다.
- 가능하면 성능이 더 우수한 PrintWriter를 사용하자.

[참고] PrintStream은 우리가 지금까지 많이 사용해왔다. **System클래스의 static 멤버인 out과 err.** 즉, `System.out, System.err`이 **PrintStream**이다.

**[PrintStream의 생성자와 메서드]**

![PrintStream의 생성자와 메서드](https://user-images.githubusercontent.com/56071088/134027749-caca562d-95cf-43b6-9a68-8b13ab69caf0.png)

**`printf()`** 
- JDK 1.5 부터 추가된 것
- C언어와 같이 편리한 형식화된 출력을 지원하게 되었다.
- printf()에 사용돌 수 있는 옵션은 Java API 문사에서 Formatter 클래스를 참고하면 된다.

**[정수와 출력에 사용될 수 있는 옵션]**

![정수와 출력에 사용될 수 있는 옵션](https://user-images.githubusercontent.com/56071088/134030488-af26f8df-a7cb-4d84-b801-8864ce6d4566.png)

**[문자열의 출력에 사용될 수 있는 옵션]**

![문자열의 출력에 사용될 수 있는 옵션](https://user-images.githubusercontent.com/56071088/134030476-f8720160-5bca-4040-b06b-fc9d1dbdc7ee.png)

**[실수의 출력에 사용될 수 있는 옵션]**

![실수이 출력에 사용될 수 있는 옵션](https://user-images.githubusercontent.com/56071088/134030482-82e83d7c-1093-444b-81fe-6505cb4a038d.png)

**[특수문자를 출력하는 옵션]**

![특수문자를 출력하는 옵션](https://user-images.githubusercontent.com/56071088/134030483-519e7727-3f59-4e68-a888-086b65a71131.png)

**[날짜와 시간의 출력에 사용될 수 있는 옵션]**

![날짜와 시간의 출력에 사용될 수 있는 옵션](https://user-images.githubusercontent.com/56071088/134030486-2c4c1d2d-c18b-468a-9bc7-4bed7ea3aea4.png)

## 문자기반 스트림

**`문자기반 스트림`** : **문자데이터를 다루는데 사용된다**는 것을 제외하고는 바이트기반 스트림과 문자기반 스트림의 사용방법은 거의 같다.

### Reader, Writer

- Byte기반 스트림의 조상이 InputStream, OutputStream인 것과 같이
- **문자기반의 스트림에서는 Reader, Writer가 문자 기반스트림의 조상이다.** 
- Reader, Writer의 메서드는 byte[] 배열 대신 char[] 배열을 사용한다는 것을 제외하고는 InputStream, OutputStream의 메서드와 다르지 않다.

**문자기반 스트림이라는 것이 단순히 2 Byte로 스트림을 처리하는 것만을 의미하지는 않는다. 문자 데이터를 다루는데 필요한 또 하나의 정보는 Encoding이다.**
- 문자기반 스트림, 즉 Reader/Writer 그리고 그 자손들은 **여러 종류의 Encoding과 Java에서 사용하는 유니코드(UTF-16)간의 변환을 자동적으로 처리**해준다.
  - Reader : 특정 Encoding -> 유니코드(UTF-16) 
  - Writer : 유니코드(UTF-16) -> 특정 Encoding
  - 
**[Reader의 메서드]**

![Reader의 메서드](https://user-images.githubusercontent.com/56071088/134033303-88c92a02-b356-49f7-85c2-6c1050848e00.png)

**[Writer의 메서드]**

![Writer의 메서드](https://user-images.githubusercontent.com/56071088/134033310-a1df243b-7e3a-4dbf-be7e-8ddd92c2bd6a.png)

### FileReader, FileWriter

**`FileReader, FileWriter`**
- 문자기반의 파일 입출력
- 텍스트 파일의 입출력에 사용한다.

**[FileReader를 사용하는 예제]**

- 같은 내용의 text파일(test.txt)을 한번은 FileInputStream으로 다른 한번은 FileReader로 읽어서 화면에 출력하는 예제
- FileInputStream을 사용했을 때는 `한글`이 **깨져서 출력**되는 것을 알 수 있다. 

```java
import java.io.*;

class FileReaderEx1 {
	public static void main(String args[]) {
		try {
			String fileName = "test.txt";
			FileInputStream fis = new FileInputStream(fileName);
			FileReader	    fr  = new FileReader(fileName);

			int data =0;

			// FileInputStream을 이용해서 파일내용을 읽어 화면에 출력한다.
			while((data=fis.read())!=-1) {
				System.out.print((char)data);
			}
			System.out.println();
			fis.close();

			// FileReader를 이용해서 파일내용을 읽어 화면에 출력한다.
			while((data=fr.read())!=-1) {
				System.out.print((char)data);
			}
			System.out.println();
			fr.close();				

		} catch (IOException e) {
				e.printStackTrace();		
		}
	} // main
}
```

```json
실행결과
C:\jdk1.8\work\ch15>type test.txt
Hello, 안녕하세요?

C:\jdk1.8\work\ch15>java FileReaderEx1
Hello, Á¡¼öÀÇ ÃÑÇÕÀº
Hello, 안녕하세요?
```

### PipedReader, PipedWriter

**`PipedReader, PipedWriter`**
- Thread간에 데이터를 주고받을 때 사용된다.
- 다른 스트림과 달리 **입력과 출력 스트림**을 **하나의 스트림으로 연결(connect)** 해서 데이터를 주고 받는 특징이 있다.
- 스트림을 생성한 다음에 어느 한쪽 Thread에서 **connect()를 호출해서 입력스트림과 출력스트림을 연결한다.**
- 입출력을 마친 후에는 **어느 한쪽 스트림만 닫아도 나머지 스트림은 자동으로 닫힌다.**
- 이 점을 제외하고는 일반 입출력방법과 다르지 않다.

**[2 Thread가 PipedReader, PipedWriter를 이용해서 서로 메시지를 주고받는 예제]**
- **Thread를 시작하기 전에 PipedReader, PipedWriter를 연결해야 한다는 것에 유의!!**
  - StringWriter는 CharArrayWriter처럼 Memoey를 사용하는 스트림인데 내부적으로 StringBuffer를 가지고 있어서 출력하는 내용이 여기에 저장된다.

```java
import java.io.*;

public class PipedReaderWriter {
	public static void main(String args[]) {
		InputThread   inThread = new InputThread("InputThread");
		OutputThread outThread = new OutputThread("OutputThread");

        //PipedReader와 PipedWriter를 연결한다.
		inThread.connect(outThread.getOutput());	

		inThread.start();
		outThread.start();
	} // main
}

class InputThread extends Thread {
	PipedReader  input = new PipedReader();
	StringWriter sw    = new StringWriter();

	InputThread(String name) {
		super(name);		// Thread(String name);
	}

	public void run() {
		try {
			int data = 0;

			while((data=input.read()) != -1) {
				sw.write(data);
			}
			System.out.println(getName() + " received : " + sw.toString());
		} catch(IOException e) {}
	} // run

	public PipedReader getInput() {
		return input;
	}

	public void connect(PipedWriter output) {
		try {
			input.connect(output);
		} catch(IOException e) {}
	} // connect
}

class OutputThread extends Thread {
	PipedWriter output = new PipedWriter();

	OutputThread(String name) {
		super(name);		// Thread(String name);
	}

	public void run() {
		try {
			String msg = "Hello";
			System.out.println(getName() + " sent : " + msg);
			output.write(msg);
			output.close();
		} catch(IOException e) {}
	} // run

	public PipedWriter getOutput() {
		return output;
	}

	public void connect(PipedReader input) {
		try {
			output.connect(input);
		} catch(IOException e) {}
	} // connect
}
```

### StringReader, StringWriter

**`StringReader, StringWriter`**
- CharArrayReader, CharArrayWriter와 같이 입출력 대상이 Memory인 스트림이다.
- StringWriter에 출력되는 데이터는 내부의 StringBuffer에 저장되며 StringWriter의 getBuffer(), toString() 을 이용하여 저장된 데이터를 얻을 수 있다.

```java
StringBuffer getBuffer() : StringWriter에 출력한 데이터가 저장된 StringBuffer를 반환한다.
String toString() : StringWriter에 출력된 (StringBuffer에 저장된) 문자열을 반환한다.
```

**[StringReader, StringWriter예제]**

```java
import java.io.*;

class StringReaderWriterEx {
	public static void main(String[] args) {
		String inputData = "ABCD";
		StringReader input  = new StringReader(inputData);
		StringWriter output = new StringWriter();

		int data = 0;

		try {
			while((data = input.read())!=-1) {
				output.write(data);	// void write(int b)
			}
		} catch(IOException e) {}

		System.out.println("Input Data  :" + inputData);
		System.out.println("Output Data :" + output.toString());
//		System.out.println("Output Data :" + output.getBuffer().toString());
	}
}
```

```json
실행결과
Input Data : ABCD
Output Data : ABCD
```

## 문자 기반의 보조 스트림

### BufferedReader, BufferedWriter

**`BufferedReader, BufferedWriter`**
- Buffer를 이용해서 입출력의 효율을 높일 수 있도록 해주는 역할
- **Buffer를 이용하면 입출력의 효율이 비교할 수 없을 정도로 좋아지기 때문에 사용하는 것이 좋다.**
- `BufferedReader`의 `readLine()`을 사용하면 **데이터를 line단위로 읽을** 수 있고  
- `BufferedWriter`는 `newLine()`이라는 **줄바꿈 해주는 메서드**를 가지고 있다.

**[BufferedReader, BufferedWriter예제]**
- BufferedReader의 readLine()을 이용해서 File을 Line단위로 읽은 다음 indexOf()를 이용해서 `;`를 포함하고 있는지 확인하여 출력하는 예제
- File에서 특정 문자 또는 문자열을 포함한 Line을 쉽게 찾아낼 수 있음을 보여준다.

```java
import java.io.*;

class BufferedReaderEx1 {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("BufferedReaderEx1.java");
			BufferedReader br = new BufferedReader(fr);

			String line = "";
			for(int i=1;(line = br.readLine())!=null;i++) { 
				//  ";"를 포함한 라인을 출력한다.
				if(line.indexOf(";")!=-1)	
					System.out.println(i+":"+line);
			}
                     
            br.close();
		} catch(IOException e) {}
	} // main
}
```

### InputStreamReader, OutputStreamWriter

**`InputStreamReader, OutputStreamWriter`**
- Byte기반 스트림을 char기반 스트림으로 연결시켜주는 역할을 한다.
- 그리고 Byte기반 스트림의 data를 지정된 Encoding의 문자 데이터로 변환하는 작업을 수행한다.
- InputStreamReader, OutputStreamWriter는 Reader, Writer의 자손이다.

**[InputStreamReader, OutputStreamWriter의 생성자와 메서드]**

![InputStreamReader, OutputStreamWriter의 생성자와 메서드](https://user-images.githubusercontent.com/56071088/134049002-12eb9464-4df2-47d2-82ac-2f25104fb109.png)

한글 윈도우에서 중국어로 작성된 File을 읽을 때 
- `InputStreamReader(InputStream in, String encoding)` 을 이용해서 Encoding을 따로 지정해주어야 한다.
  - Encoding을 지정해주지 않는다면 OS에서 사용하는 Encoding을 사용해서 File을 해석해서 보여주기 때문에 원래 작성된 데로 볼 수 없을 것이다.
- `OutputStreamWriter(OutputStream out, String encoding)` 을 이용해서 File에 text데이터를 저장할 때 Encoding을 지정해주어야 한다.
  - Encoding을 지정하지 않으면 OS에서 지원하는 Encoding으로 data를 저장할 것이다.

[참고] 시스템에서 `sun.jnu.encoding` 의 값을 보면 OS에서 사용하는 Encoding의 종류를 알 수 있다.

```java
Properties prop = System.getProperties();
System.out.println(prop.get("sun.jun.encoding"));
```

## 표준입출력과 File

### 표준입출력 - System.in, System.out, System.err

**`표준입출력`** : **콘솔(console, 도스창)을 통항 데이터 입력과 console로의 데이터 출력을 의미한다.**

Java에서는 표준 입출력(standard I/O)를 위해 3가지 입출력 스트림, System.in, System.out, System.err 을 제공하는데,
- 이들은 Java Application의 실행과 동시에 사용할 수 있게 자동적으로 생성되기 때문에 개발자가 별도로 스트림을 생성하는 코드를 작성하지 않고도 사용이 가능하다.
- Java를 처음 시작할 때부터 지금까지 줄 곧 사용해온 System.out을 스트림의 생성없이 상요할 수 있었던 것이 바로 이러한 이유 때문이다.

```java
System.in : 콘솔로부터 data를 입력받는데 사용
System.out : 콘솔로 data를 출력하는데 사용
System.err : 콘솔로 data를 출력하는데 사용
```

**[Java에서의 표준 입출력]**

![Java에서의 표준 입출력](https://user-images.githubusercontent.com/56071088/134128216-8f09d438-18dc-4017-96a0-4ebdf3ed5409.png)

**[System 클래스의 소스]**

```java
public final class System {
	public final static InputStream in = nullInputStream();
	public final static PrintStream out = nullInputStream();
	public final static PrintStream err = nullInputStream();
	...
}
```

- `in, out, err` : System클래스에 선언된 **클래스 변수(static 변수)** 이다.
- 선언부분만을 보면 in, out, err 타입은 InputStream, PrintStream이지만 
- **실제로는 BufferedInputStream, BufferedOutputStream의 인스턴스를 사용한다.**

**[System.in을 이용한 표준 입출력 예제]**

```java
import java.io.*;

class StandardIOEx1 {
	public static void main(String[] args) {
		try {
			int input = 0;

			while((input=System.in.read())!=-1) {
				System.out.println("input :" + input + ", (char)input :" + (char)input);
			}
		} catch(IOException e) {
			e.printStackTrace();
		}
	} // main
}
```

여기서 

```java
while( ( input = System.in.read() ) != -1) {
}
```

예제를 실행하여 `System.in.read()` 가 호출되면, 코드의 진행을 멈추고 콘솔에 cursor가 깜빡이며 사용자의 입력을 기다린다.
- `콘솔입력`은 Buffer를 가지고 있기 때문에 편집이 가능, 한번에 Buffer size만큼의 입력이 가능하다.
- `Enter키, 입력의 끝을 알리는 ^Z키`를 누르기 전까지는 아직 데이터가 입력 중인 것으로 간주되어 **cursor가 입력을 계속 기다리는 상태**인 `Blocking상태`에 머무르게 된다.
  - data를 입력하고 `Enter키`를 누르면 `입력대기상태`에서 벗어나 입력된 데이터를 읽기 시작하고 입력된 데이터를 모두 읽으면 `다시 입력대기상태`가 된다.
  - `^Z`를 누르면, `read()`는 **입력이 종료되었음을 인식하고 -1을 반환하여 while문을 벗어나 Program이 종료된다.**

[참고] 
- Windows : `^Z`, Unix : `^d` 를 누르는 것이 **스트림의 끝을 의미한다.**
- **Windows의 console**은 **한 번에 최대 255자 까지만 입력이 가능하다.**

`Enter키`를 누르는 것은 2 개의 특수문자 `(\r, \n)` 이 입력된 것으로 간주된다.
- `\r` : **캐리지 리턴(carriage return)** : cursor를 현재 line의 첫 번째 컬럼으로 이동
- `\n` : cursor를 다음 줄로 이동시키는 `줄바꿈(newline)` 이 수행되어 다음 줄의 

한 가지 문제는  `Enter키`도 사용자 입력으로 간주되어 매 입력마다 `\r, \n`이 붙기 때문에 이 들을 제거해주어야 하는 불편함이 있다.
- `System.in`에 `BufferedReader`를 이용해서 `readLine()`을 통해 **line단위로 data를 입력받으면 된다.**

Java에서 console을 통한 입력에 대한 지원이 미약했기 때문에, `Scanner, Console` 같은 클래스가 추가되면서 많이 보완되었다.

### 표준입출력의 대상변경 - setOut(), setErr(), setIn()

**System.in, System.out, System.err**의 입출력대상이 console화면이지만,

**`setIn(), setOut(), setErr()`** : **입출력을 console이외에 다른 입출력 대상으로 변경하는 것이 가능하다.**

|메서드|설명|
|---|---|
|static void setOut(PrintStream out)|System.out의 출력을 지정된 PrintStream으로 변경|
|static void setErr(PrintStream err)|System.err의 출력을 지정한 PrintStream으로 변경|
|static void setIn(PrintStream in)|System.in의 입력을 지정한 InputStream으로 변경|

**그러나, JDK1.5부터 Scanner클래스가 제공되면서 System.in으로부터 data를 입력받아 작업하는 것이 편리해졌다!!**

**[System.setOut()을 통한 표준입출력 대상을 바꾸는 예제]**

```java
import java.io.*;

class StandardIOEx3 {
	public static void main(String[] args) {
		PrintStream      ps  = null;
		FileOutputStream fos = null;

		try {
			fos = new FileOutputStream("test.txt");
			ps  = new PrintStream(fos);
			System.setOut(ps);    //  System.out의 출력대상을 test.txt파일로 변경
		} catch(FileNotFoundException e) {
			System.err.println("File not found.");
		}

		System.out.println("Hello by System.out");		
		System.err.println("Hello by System.err");		
	}
}
```

```json
C:\jdk1.8\work\ch15>java StandardIOEx3
Hello by System.err

C:\jdk1.8\work\ch15>type test.txt
Hello by System.out

C:\jdk1.8\work\ch15>
```

```java
fos = new FileOutputStream("test.txt");
ps  = new PrintStream(fos);
System.setOut(ps);    //  System.out의 출력대상을 test.txt파일로 변경
```

- `System.out의 출력소스`를 **text.txt파일**로 변경하였기 때문에 System.out을 이용한 출력은 모두 test.txt에 저장된다.
- 그래서 실행결과에는 System.err를 이용한 출력만 나타난다.

### RandomAccessFile

**[RandomAccessFile의 상속 계층도]**

![RandomAccessFile의 상속 계층도](https://user-images.githubusercontent.com/56071088/134140144-f57f593c-44b3-4da2-beb0-69760c199a46.png)

Java 에서는 입력과 출력이 각각 분리되어 별도로 작업을 하도록 설계되어 있다.

하지만, **`RandomAccessFile`** : **하나의 클래스로 File에 대한 입력과 출력을 모두 할 수 있도록 되어 있다.**
- InputStream, OutputStream으로부터 상속받지 않고, `DataInput인터페이스, DataOutput인터페이스`를 **모두 구현했기 때문에 읽기과 쓰기 모두 가능하다.**

사실, DataInputStream, DataOutputStream은 각각 DataInput인터페이스, DataOutput인터페이스를 각각 구현했다. 

이 2 클래스의 **기본 자료형(primitive data type)을 읽고 쓰기 위한 메서드 들**은 **DataInput인터페이스, DataOutput인터페이스에 정의되어 있다.**

따라서, `RandomAccessFile클래스`도 DataInputStream, DataOutputStream처럼, **기본 자료형 단위로 data를 읽고 쓸 수 있다!!**

RandomAccessFile클래스의 가장 큰 장점 : File의 어느 위치에나 읽기/쓰기가 가능하다
- 다른 입출력 클래스들은 입출력소스에 순차적으로 읽기/쓰기를 하기 때문에 읽기와 쓰기가 제한적이다.
- 그에 반해, RandomAccessFile클래스는 **File에 읽고 쓰는 위치에 제한이 없다.**

이러한 것이 가능한 이유 : **내부적으로 File 포인터**를 사용하는데, **입출력 시에 작업이 수행되는 곳이 바로 File 포인터가 위치한 곳이 된다.**
- **File 포인터의 위치는 File의 제일 첫부분(0부터 시작)** 이며, read 또는 write를 수행할 때 마다 **작업이 수행된 다음 위치로 이동하게 된다.**
- File의 임의의 위치에 있는 내용에 대해서 작업하고자 한다면, 먼저 **파일 포인터를 원하는 위치로 옮긴 다음 작업을 해야 한다.**

`getFilePointer()` : **현재 작업 중인 File에서 File 포인터의 위치를 알고 싶을 때**

`seek(long pos)나 skipBytes(int n)` : **File 포인터의 위치를 옮길 때** 

**[RandomAccessFile의 생성자와 메서드]**

![RandomAccessFile의 생성자와 메서드](https://user-images.githubusercontent.com/56071088/134144318-08d9403a-0b43-4938-9fa0-45ea9821dc8a.png)

- RandomAccessFile의 인스턴스를 `rw` mode로 생성할 때, **지정된 File이 없으면 새로운 File을 생성한다.**

**[RandomAccessFile 사용 예시]**
- `rw mode`로 사용할 때, `seek(long pos)`를 이용하여, 읽고 쓸 때, 파일 포인터의 위치를 원하는 위치로 잘 변경해주어야 한다.
- 파일 포인터의 위치는 data type의 크기 만큼 이동한다.
- EX) int : 4 , long : 8
- readInt()를 호출했을 때 아무것도 읽지 못한다면 EOFException이 발생한다.
- `raf.seek(0)` : 파일 포인터의 위치를 다시 처음으로 이동시킬 수 있다.

```java
import java.io.*;

class RandomAccessFileEx2 {
	public static void main(String args[]) {
//				      번호, 국어, 영어, 수학					
		int[] score = {	1, 100,  90,  90,
					    2,  70,  90, 100,
						3, 100, 100, 100, 
						4,  70,  60,  80, 
						5,  70,  90, 100
					   }; 

		try {
			RandomAccessFile raf = new RandomAccessFile("score2.dat", "rw");
			
			for(int i=0; i<score.length;i++) {
				raf.writeInt(score[i]);				
			}
			
			// 파일 포인터의 위치를 다시 처음으로 이동
			raf.seek(0);

			while(true) {
				System.out.println(raf.readInt());
			}
			
		} catch (EOFException eof) {
			// readInt()를 호출했을 때 더 이상 읽을 내용이 없으면 EOFException이 발생한다.
		} catch (IOException e) {
			e.printStackTrace();		
		}
	} // main
}
```

### File

File은 기본적이면서도 가장 많이 사용되는 입출력 대상이기 때문에 중요하다.

Java에서는 File클래스를 통해서 File과 Directory를 다룰 수 있도록 하고 있다. 
- 그래서 File인스턴스는 File일 수도 있고, Directory일 수도 있다.

**[File의 생성자와 Directory와 관련된 메서드]**

![File의 생성자와 경로와 관련된 메서드](https://user-images.githubusercontent.com/56071088/134147071-fb46da5a-4cf8-419c-9c47-e4f7e250e801.png)

**[Directory와 관련된 File의 멤버변수]**

![경로와 관련된 File의 멤버변수](https://user-images.githubusercontent.com/56071088/134147124-74276003-fa77-45c4-ad1d-ab7c40326f87.png)

- File의 경로(path)와 Directory나 File의 이름을 구분하는데 사용되는 구분자(Separator)가 OS마다 다를 수 있기 때문에
- OS 독립적으로 Program을 작성하기 위해서는 반드시 위의 멤버변수들을 이용해야 한다.
- 만일, Windows에서 사용하는 구분자(separator)를 코드에 직접 적어놓았다면, 이 코드는 다른 OS에서 오류를 일으킬 수 있다.

**[File인스턴스를 생성하고 메서드를 이용해서 File의 Directory와 Separator등의 정보를 출력하는 예제]**

```java
import java.io.*;

class FileEx1 {
	public static void main(String[] args) throws IOException
	{
		File f = new File("c:\\jdk1.8\\work\\ch15\\FileEx1.java");
		String fileName = f.getName();
		int pos = fileName.lastIndexOf(".");

		System.out.println("경로를 제외한 파일이름 - " + f.getName());
		System.out.println("확장자를 제외한 파일이름 - " + fileName.substring(0,pos));
		System.out.println("확장자 - " + fileName.substring(pos+1));

		System.out.println("경로를 포함한 파일이름 - "		+ f.getPath());
		System.out.println("파일의 절대경로        - "	+ f.getAbsolutePath());
		System.out.println("파일의 정규경로        - "	+ f.getCanonicalPath());
		System.out.println("파일이 속해 있는 디렉토리 - "	+ f.getParent());
		System.out.println();
		System.out.println("File.pathSeparator - "		+ File.pathSeparator);
		System.out.println("File.pathSeparatorChar - "  + File.pathSeparatorChar);
		System.out.println("File.separator - "		+ File.separator);
		System.out.println("File.separatorChar - "	+ File.separatorChar);
		System.out.println();
		System.out.println("user.dir=" + System.getProperty("user.dir"));
		System.out.println("sun.boot.class.path=" + System.getProperty("sun.boot.class.path"));
	}
}
```

```json
실행결과)

경로를 제외한 파일이름 - FileEx1.java
확장자를 제외한 파일이름 - FileEx1
확장자 - java
경로를 포함한 파일이름 - c:\jdk1.5\work\ch14\FileEx1.java
파일의 절대경로        - c:\jdk1.5\work\ch14\FileEx1.java
파일이 속해 있는 디렉토리 - c:\jdk1.5\work\ch14

File.pathSeparator - ;
File.pathSeparatorChar - ;
File.separator - \
File.separatorChar - \


user.dir=E:\Eclipse_Source\JAVA\My_Lib

sun.boot.class.path=C:\Program Files (x86)\Java\jre6\lib\resources.jar;C:\Program Files (x86)\Java\jre6\lib\rt.jar;C:\Program Files (x86)\Java\jre6\lib\sunrsasign.jar;C:\Program Files (x86)\Java\jre6\lib\jsse.jar;C:\Program Files (x86)\Java\jre6\lib\jce.jar;C:\Program Files (x86)\Java\jre6\lib\charsets.jar;C:\Program Files (x86)\Java\jre6\lib\modules\jdk.boot.jar;C:\Program Files (x86)\Java\jre6\classes
```

- **절대 경로(absolute path) : 파일 시스템의 루트(root)로부터 시작하는 File의 전체 경로를 의미**
  - OS에 따라 다르지만, 하나의 File에 대해 둘 이상의 절대 경로가 존재할 수 있다.
  - 현재 directory를 의미하는 `.` 와 같은 기호나 링크를 포함하고 있는 경우가 이에 해당한다.

그러나 **정규경로(canonical path)는 기호나 링크 등을 포함하지 않는 유일한 경로를 의미**

`시스템 속성 중에서 user.dir`의 값 : 현재 Program이 실행 중인 directory를 알 수 있다.

`sun.boot.class.path`라는 시스템속성에 기본적인 classpath가 있어서 기본적인 경로들은 이미 설정되어 있다.
- 그래서 처음 JDK 설치 후 classpath를 따로 지정해주지 않아도 되는 것이다.

**[File인스턴스를 생성하는 다양한 방법들]**

```java
File f = new File("c:\\jdk1.8\\work\\ch15\\FileEx1.java");
File f = new File("c:\\jdk1.8\\work\\ch15", "FileEx1.java");
File dir = new File("c:\\jdk1.8\\work\\ch15");
File f = new File(dir, "FileEx1.java");
```

- File인스턴스를 생성했다고 해서 파일이나 디렉터리가 생성되는 것은 아니라는 것이다.
- 파일명이나 디렉토리명으로 지정된 문자열이 유효하지 않더라도 컴파일 에러나 예외를 발생시키지 않는다.

**새로운 파일을 생성하기 위해서는 File인스턴스를 생성한 다음, 출력스트림을 생성하거나 createNewFile()를 호출해야 한다.**

```java
1. 이미 존재하는 파일을 참조할 때 :
File f = new File("c:\\jdk1.8\\work\\ch15", "FileEx1.java");

2. 기존에 없는 파일을 새로 생성할 때 :
File f = new File("c:\\jdk1.8\\work\\ch15", "FileEx1.java");
f.createNewFile(); // 새로운 파일이 생성된다.
```

**[File의 메서드]**

![File의 메서드](https://user-images.githubusercontent.com/56071088/134210715-03f2b363-8289-4fa8-9518-10cc345e7f16.png)

## 직렬화(Serialization)

객체를 컴퓨터에 저장했다가 다음에 다시 꺼내 쓰거나 네트워크를 통해 컴퓨터 간에 서로 객체를 주고 받는 것에 사용되는 것이 `직렬화(Serialization)`이다.  

### 직렬화란?

![객체의 직렬화와 역직렬화](https://user-images.githubusercontent.com/56071088/134279398-57e6ee22-887f-4269-8b46-f0e06a1ae0be.png)

**`직렬화(Serialization)`** : **객체를 데이터 스트림으로 만드는 것**
- 객체에 저장된 데이터를 스트림에 쓰기(write)위해 연속적인(serial) 데이터로 변환하는 것

**`역직렬화(Deserialization)`** : **스트림으로 부터 데이터를 읽어서 객체를 만드는 것**

사실 객체를 저장하거나 전송하려면 직렬화, 역직렬화 하는 것은 당연한 것이다.

**`객체`** 는 **클래스에 정의된 인스턴스변수의 집합**이다. 
- 객체에는 **클래스 변수(static)나 메서드가 포함되지 않는다.**
- 객체는 **오직 인스턴스변수들로만 구성되어 있다.**

**사실 객체에는 메서드가 포함되어 있지 않다!!**
- 인스턴스 변수는 인스턴스마다 다른 갓을 가질 수 있어야하기 때문에 별도의 메모리공간이 필요하지만
- 메서드는 변하는 것이 아니라서 메모리를 낭비해 가면서 인스턴스마다 같은 내용의 코드(메서드)를 포함시킬 이유는 없다.

`객체를 저장한다는 것`은 **객체의 모든 인스턴스 변수의 값을 저장한다는 것**이다.
- `어떤 객체를 저장한다면`, **현재 객체의 모든 인스턴스변수의 값을 저장**하면 된다.
- `저장했던 객체를 다시 생성`하려면, **객체를 생성한 후에 저장했던 값을 읽어서 생성한 객체의 인스턴스변수에 저장**하면 되는 것이다.

class에 정의된 인스턴스변수가 단순히 기본형일 때는 인스턴스변수의 값을 저장하는 일이 간단

인스턴스 변수의 타입이 참조형일 때는 그리 간단하지 않다.
- EX) 인스턴스 변수의 타입이 배열이라면, 배열에 저장된 모든 값들도 저장되어야 할 것이다.

이것을 쉽게 가능하게 해주는 것이 **ObjectInputStream, ObjectOutputStream**이다.

### ObjectInputStream, ObjectOutputStream

**`ObjectOutputStream`** : 직렬화(객체를 스트림에 출력)

**`ObjectInputStream`** : 역직렬화(스트림을 객체에 입력)
- ObjectInputStream, ObjectOutputStream은 각각 InputStream, OutputStream을 직접 상속받지만, 기반스트림을 필요로 하는 **보조스트림**이다.
- 그래서, **객체를 생성할 때 입출력(직렬화/역직렬화)할 스트림을 지정**해주어야 한다.

**[직렬화 방법 예시]**

```java
ObjectInputStream(InputStream in)
ObjectOutputStream(OutputStream out)

FileOutputStream fos = new FileOutputStream("objetfile.ser");
ObjectOutputStream out = new ObjectOutputStream(fos);

out.writeObject(new userInfo());
```

objectfile.ser이라는 file에 UserInfo객체를 직렬화하여 저장한다.
- **출력할 스트림(FileOutputStream)을 생성**해서 **이를 기반스트림으로 하는 ObjectOutputStream을 생성한다.**
- ObjectOutputStream의 writeObject(Object obj)를 사용해서 객체를 출력하면, 객체가 파일에 직렬화되어 저장된다.

**[역직렬화 방법 예시]**

```java
FileInputStream fis = new FileInputStream("objectfile.ser");
ObjectInputStream in = new ObjectInputStream(fis);

UserInfo info = (UserInfo)in.readObject();
```

입력스트림을 사용하고 readObject를 사용하여 저장된 데이터를 읽기만 하면 객체로 역직렬화된다.
- readObject()의 반환형이 Object이기 때문에 객체 원래의 타입으로 형변환 해주어야 한다.

**[ObjectInputStream, ObjectOutputStream의 메서드]**

![ObjectInputStream, ObjectOutputStream의 메서드](https://user-images.githubusercontent.com/56071088/134282404-a616e4fc-c016-4820-9068-ec2938ea1323.png)

- 이 메서드들은 직렬화와 역직렬화를 직접 구현할 때 사용된다.
- defaultReadObject(), defaultWriteObject()는 자동 직렬호를 수행한다.

객체를 직렬화/역직렬화하는 작업은 객체의 모든 인스턴스변수가 참조하고 있는 모든 객체에 대한 것이기 때문에 상당히 복잡하며 시간도 오래 걸린다.
- readObject(), writeObject()를 사용한 자동 직렬화가 편리하지만
- 직렬화작업시간을 단축시키려면 직렬화하고자 하는 객체의 클래스에 readObject(), writeObject()를 직접 구현해주어야 한다.

```java
private void writeObejct(ObjectOutputStream out) throws IOException {
	// write메서드를 사용해서 직렬화를 수행한다.
}

private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
	// read메서드를 사용해서 역직렬화를 수행한다.
}
```

### 직렬화가 가능한 클래스 만들기 - Serializable, transient

**직렬화하고자 하는 클래스가 java.io.Serializble인터페이스를 구현하면 된다!!**

```java
public class userInfo implements java.io.Serializable {
	String name;
	String password;
	int age;
}

public interface Serializable {}

public class SuperUserInfo implements Serializable {
	String name;
	String password;
}

public class UserInfo extends SuperUserInfo {
	int age;
}
```

- **Serialzable인터페이스느 아무런 내용도 없는 빈 인터페이스, 직렬화를 고려하여 작성한 클래스인지를 판단하는 기준이 된다.**
- Serializable를 구현한 클래스를 상속받는다면, Serializable을 구현하지 않아도 된다.

**[Object는 Serializable을 구현하지 않았기 깨문에 직렬화할 수 없다.]**

```java
public class UserInfo implements Serializable {
	String name;
	String password;
	int age;
	Object obj = new Object(); // Object객체는 직렬화할 수 없다.
}
```

- 모든 객체의 최고조상인 `Object`는 Serializable을 구현하지 않았기 때문에 직렬화할 수 없다.
- 따라서 위의 클래스의 객체를 직렬화하면 `java.io.NotSerializableException`이 발생한다.
  - 직렬화할 수 없는 클래스의 객체 `(Object obj = new Object();)` 를 인스턴스변수가 참조하고 있기 때문에

**[transient제어자]**

```java
public class UserInfo implements Serializable {
	String name;
	transient String password;
	int age;
	transient Object obj = new Object(); // 직렿화 댓아
}
```

**`transient제어자`** : **직렬화 대상에서 제외시키는 제어자**
- **transient가 붙은 인스턴스변수의 값**은 **그 타입의 기본값으로 직렬화된다.**
- password와 같이 보안상 직렬화가 되면 안 되는 값에 transient를 사용할 수 있다.
- UserInfo객체를 역직렬화하면 참조변수인 obj, password의 값은 **null**이 된다.

**[생성한 객체를 직렬화하여 파일(UserInfo.ser)에 저장하는 예제]**
   
```java
import java.io.*;
import java.util.ArrayList;

class UserInfo implements java.io.Serializable {
	String name;
	String password;
	int age;

	public UserInfo() {
		this("Unknown", "1111", 0);
	}

	public UserInfo(String name, String password, int age) {
		this.name = name;	
		this.password = password;	
		this.age = age;	
	}

	public String toString() {
		return "("+ name + "," + password + "," + age + ")";
	}
}

public class SerialEx1 {
	public static void main(String[] args) {
		try {
			String fileName = "UserInfo.ser";
			FileOutputStream     fos = new FileOutputStream(fileName);
			BufferedOutputStream bos = new BufferedOutputStream(fos);

			ObjectOutputStream out = new ObjectOutputStream(bos);
			
			UserInfo u1 = new UserInfo("JavaMan","1234",30);
			UserInfo u2 = new UserInfo("JavaWoman","4321",26);

			ArrayList<UserInfo> list = new ArrayList<>();
			list.add(u1);
			list.add(u2);

			// 객체를 직렬화한다.
			out.writeObject(u1);
			out.writeObject(u2);
			out.writeObject(list);
			out.close();
			System.out.println("직렬화가 잘 끝났습니다.");
		} catch(IOException e) {
			e.printStackTrace();
		}
	} // main
} // class
```

- Buffer를 이용한 FileOutputStream을 기반으로 하는 ObjectOutputStream을 생성한 다음, 
- writeObject()를 이용해서 객체를 ObjectOutputStream에 출력하면,
- UserInfo.ser파일에 객체가 직렬화되어 저장된다.
- **객체에 정의된 모든 인스턴스변수에 대한 참조가 찾아들어가기 때뭉에 상당히 복잡하고 시간이 걸리는 작업이 될 수 있다.**
- ArrayList와 같은 객체를 직렬화하면 ArrayList에 저장된 모든 객체들과 각 객체의 인스턴스변수가 참조하고 있는 객체들까지 모두 직렬화된다.

**[직렬화환 객체를 역직렬화하는 예제]**

```java
import java.io.*;
import java.util.ArrayList;

public class SerialEx2 {
	public static void main(String[] args) {
		try {
			String fileName = "UserInfo.ser";
			FileInputStream     fis = new FileInputStream(fileName);
			BufferedInputStream bis = new BufferedInputStream(fis);

			ObjectInputStream in = new ObjectInputStream(bis);

			// 객체를 읽을 때는 출력한 순서와 일치해야한다.
			UserInfo u1 = (UserInfo)in.readObject();
			UserInfo u2 = (UserInfo)in.readObject();
			ArrayList list = (ArrayList)in.readObject();

			System.out.println(u1);
			System.out.println(u2);
			System.out.println(list);
			in.close();
		} catch(Exception e) {
			e.printStackTrace();
		}
	} // main
} // class
```

- ObjectInputStream의 readObjet()로 직렬화한 객체를 역직렬화하였는데, **readObject()의 반환형이 Object이므로 원래의 타입으로 형변환(type casting)을 해주어야 한다.**
- **객체를 역직렬화 할 때는 직렬화할 때의 순서와 일치해야한다는 것이다.**
  - EX) 객체 u1,u2,list의 순서로 직렬화, 역직렬화 할 때 -> u1,u2,list의 순서로 처리
- 그래서 직렬화할 객체가 많을 때는 각 객체를 개별적으로 직렬화하는 것보다 **ArrayList와 같은 컬렉션에 저장해서 직렬화하는 것이 가장 좋다.** 

**[직렬화되지 않는 조상으로부터 상속받은 인스턴스변수에 대한 직렬화를 구현한 것]**

```java
import java.io.*;

class SuperUserInfo {
	String name;
	String password;

	SuperUserInfo() {
		this("Unknown","1111");
	}

	SuperUserInfo(String name, String password) {
		this.name = name;
		this.password = password;
	}
} // class SuperUserInfo

public class UserInfo2 extends SuperUserInfo implements java.io.Serializable {
	int age;

	public UserInfo2() {
		this("Unknown", "1111", 0);
	}

	public UserInfo2(String name, String password, int age) {
		super(name, password);
		this.age = age;	
	}

	public String toString() {
		return "("+ name + "," + password + "," + age + ")";		
	}

	private void writeObject(ObjectOutputStream out)
		throws IOException {
		out.writeUTF(name);	
		out.writeUTF(password);	
		out.defaultWriteObject();
	}

	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
		name = in.readUTF();
		password = in.readUTF();
		in.defaultReadObject();
	
	}
} // class UserInfo2 
```

- 직렬화될 객체의 클래스에 writeObject(), readObject()를 추가해서 조상으로부터 상속받은 인스턴스변수인 name, passsword가 직접 직렬화되도록 해야 한다.
- 이 메서드들은 직렬화/역직렬화 작업시에 자동적으로 호출된다.
- 두 메서드의 접근 제어자가 `private`인 이유 : 단순히 미리 그렇게 하자고 정해진 규칙일 뿐이다.
  - defaultWriteObject(), defualtReadObject() : UserInfo2 클래스에 정의된 인스턴스변수들을 직렬화/역직렬화 한다.

### 직렬화가능한 클래스의 버젼관리

![직렬화 예외](https://user-images.githubusercontent.com/56071088/134304977-41734631-0af0-40e4-bd4c-b04c37801fbf.png)

직렬화된 객체를 역직렬화할 때는 직렬화 했을 때와 같은 클래스를 사용해야 한다.
- 그러나, 클래스의 이름이 같더라도 클래스의 내용이 변경된 경우 역직렬화는 실패하여 예외가 발생한다.

직렬화/역직렬화 할 때의 **클래스의 버젼이 다르면 예외가 발생**
- 객체가 직렬화될 때 클래스에 정의된 멤버들의 정보를 이용해서 `serialVersionUID`라는 클래스의 버젼을 자동생성해서 직렬화 내용에 포함된다.
- 역직렬화 할 때 클래스의 버젼을 비교한다.
- 만약, `static변수, 상수(constant), transient가 붙은 인스턴스 변수`는 **직렬화 대상에서 제외되기 때문에 직렬화에 영향을 미치지 않기 때문에 클래스의 버젼을 다르게 인식하도록 할 필요는 없다.**

네트워크로 객체를 직렬화하여 전송하는 경우, 보내는 쪽과 받는 쪽이 모두 같은 버젼의 클래스를 가지고 있어야 하는데 클래스가 조금만 변경되어도 해당 클래스를 재배포하는 것은 프로그램을 관리하기 어렵게 만든다.
- 이럴때는 **클래스의 버젼을 수동으로 관리해줄 필요가 있다.**

```JAVA
class MyData implements java.io.Serializable {
	static final long serialVersionUID = 3518731767529258119L;
	int value;
}
```

- **이렇게 클래스 내에 serialVersionUID를 정의해주면, 클래스의 내용이 바뀌어도 클래스의 버젼이 자동생성된 값으로 변경되지 않는다.**


#### 참고 링크 
- https://catsbi.oopy.io/20112bd1-0d38-48ab-b8bc-c01fded65fab
- https://reakwon.tistory.com/160
- https://developer-hm.tistory.com/m/73
