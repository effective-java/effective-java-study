# 7장 객체지향 프로그래밍2

## 객체지향 4대 특성

캡.상.추.다.

- 캡슐화(Encapsulation) : 정보 은닉(Information Hiding)
- 상속(Inheritance) : 재사용과 확장(extends)
- 추상화(Abstraction) : 모델링(Modeling)(class)(abstract)
- 다형성(Polymorphism) : 사용 편의성

## 상속(Inheritance) : 재사용과 확장 : extends

`상속` : 기존의 클래스를 **재사용** 하여 새로운 클래스로 **확장** 하는 것이다.

- 상위 클래스 - 하위 클래스 / 슈퍼 클래스 - 서브 클래스

- **분류도**

`상속(Inheritance)의 장점` : 재사용성, 유지보수성, 중복 제거, 생산성 증가

`extends` : extends 키워드를 사용하여 슈퍼 클래스를 **확장** 한다는 의미이다.

- **생성자와 초기화 블록은 상속되지 않는다.** 멤버만 상속된다.

- 서브 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

- **접근 제어자가 private 또는 default 인 멤버들은** 상속되지 않는다기 보다는 **상속은 받지만 서브 클래스로부터의 접근이 제한되는 것이다.**

```java
class Parent {
  int age;
}

class Child extends Parent {}
class Child2 extends Parent {}
class GrandChild extends Child {}
```

![상속2](https://user-images.githubusercontent.com/56071088/122073972-cc3aed80-ce33-11eb-8104-9554de58584c.jpg)

| 클래스     | 클래스의 멤버 |
| ---------- | ------------- |
| Parent     | age           |
| Child      | age           |
| Child2     | age           |
| GrandChild | age           |

- Parent 클래스에 추가된 멤버변수 age는 Parent 클래스의 모든 자손에 추가된다.
- 반대로 Parent 클래스에서 멤버변수 age를 제거 한다면, Parent 자손클래스인 Child, Child2, GrandChild에서도 제거된다. 

![상속](https://user-images.githubusercontent.com/56071088/122073284-461ea700-ce33-11eb-9adb-faf306747da9.png)

자손 클래스의 인스턴스가 생성되면

- 조상 클래스의 멤버도 함께 생성된다.
- 따로 조상 크래스의 인스턴스를 생성하지 않고도 조상 클래스의 멤버들을 사용할 수 있다.

**자손 클래스의 인스턴스가 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.**

### 클래스간의 관계 - 포함관계

상속이외에도 클래스를 **재사용** 하는 방법 : **클래스간에 '포함(Composite)' 관계를 맺어주는 것이다.**

- 한 클래스의 **멤버변수** 로 **다른 클래스 타입의 참조변수를 선언** 하는 것이다.

```java
class Circle {
  Point p = new Point(); // 원점
  int r;
}
```

### 클래스 간의 관계 결정하기

**객체 지향의 상속은 is a kind of 관계를 만족한다.**

- **하위 클래스는 상위 클래스다**
  - LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 : 객체지향 설계 5대 원칙 중 하나
  - **서브 타입(Sub-Type)은 언제나 자신의 기반 타입(Base-Type)으로 교체할 수 있어야 한다.**
  
- 하위 클래스 **is a kind of** 상위 클래스 : 하위 클래스는 상위 클래스의 한 **분류** 이다.

- Java 에서 다중 상속은 2개 이상의 상위 클래스가 있을 때, 하위 클래스는 어떠한 속성을 선택하여 재사용 및 확장을 하는 것이 모호하기에 **단일 상속** 을 선택했다.

1. 상속 관계 : `is a kind of : ~은 ~의 한 분류다.`
2. 포함 관계 : `has a : ~은 ~을 가지고 있다.`

#### Tips

```java
Card c = new Card();

System.out.println(c);
System.ou.println(c.toString());

System.out.println("Card: " + c.toString());
System.out.println(c);
```

- 참조변수의 출력, 덧셈연산자(+)를 이용한 참조변수와 문자열의 결합 : 자동적으로 **toString()이 호출** 되어 **참조변수** 를 **문자열로 대치** 한 후 처리한다.

### Object 클래스 - 모든 클래스의 조상

```java
class Tv extends Object {}
```

Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스이다. 

- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object 클래스로부터 상속받게 함으로써 이것을 가능하게 한다.

- `컴파일` 하면 자동적으로 `extends Object` 를 추가하여 **Tv 클래스가 Object 클래스로부터 상속받도록 한다.**

- 이미 어떤 클래스로부터 상속받도록 작성된 클래스에 대해서는 컴파일러가 'extends Object'를 추가하지 않는다.

- **Java 의 모든 클래스들은** Object 클래스를 상속받기 때문에 **Object 클래스에 정의된 멤버들을 사용할 수 있다.**

## 오버라이딩(Overriding)

`오버라이딩(Overriding)` : **슈퍼 클래스로부터 상속받은 메서드** 의 내용을 변경하는 것

`오버로딩(Overloading)` : **한 클래스내에 이름이 같은 메서드** 를 여러개 정의하는 것
  - 메서드의 이름이 같고, 매개변수(Parameter)의 개수와 타입, 순서가 달라야하며, 반환 타입(return)과는 무관하다.

### 오버라이딩의 조건

서브 클래스에서 오버라이딩하는 메서드는 슈퍼 클래스의 메서드와

1. **이름**이 같아야 한다.
2. **매개변수**가 같아야 한다.
3. **반환 타입**이 같아야 한다.

=> **메서드의 선언부가 일치해야 한다.**

[참고] : JDK 1.5부터 `공변 반환타입(covariant return type)` 이 추가되어, 반환타입을 자손 클래스의 타입으로 변경하는 것은 가능하도록 조건이 완화되었다.

**다만, 접근 제어자(access modifier)와 예외(Exception)는 제한된 조건 하에서만 다르게 변경할 수 있다.**

1. **접근 제어자**를 조상 클래스의 메서드 보다 **좁은 범위로 변경할 수 없다.**
   
   - 만일 **슈퍼 클래스** 에 정의된 메서드의 접근 제어자가 **protected** 라면, 이를 오버라이딩 하는 **서브 클래스**  메서드의 접근 제어자는 **protected 이거나 public** 이어야 한다.  

2. **예외** 는 조상 클래스의 메서드 보다 **많이 선언할 수 없다.**
  
  - Exception 은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있도록 선언한 것이다. 

3. **인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없다.**

- 조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의할 수 있나?
  
  - 가능하다. 하지만, 이것은 **각각의 클래스에 별개의 static 메서드를 정의하는 것이다.** 오버라이딩이 아니다. **static 멤버들은 자신이 정의된 클래스에 묶여있다고 생각해야 한다.**

### 오버로딩(Overloading) vs 오버라이딩(Overrinding)

- `오버로딩(Overloading)` : 기존에 없는 새로운 메서드를 정의하는 것 (new)
  - **한 클래스내에 이름이 같은 메서드** 를 여러개 정의하는 것
  
  - 메서드의 이름이 같고, 매개변수(Parameter)의 개수와 타입, 순서가 달라야하며, 반환 타입(return)과는 무관하다.
  
- `오버라이딩(Overriding)` : 상속받은 메서드의 내용을 변경하는 것 (change, modify)
  - **슈퍼 클래스로부터 상속받은 메서드** 의 내용을 변경하는 것
  
  - **메서드의 선언부가 일치해야 한다.** 

### super 

`super` : 서브 클래스에서 **상속받은 멤버들을 참조** 하기 위해서 사용되는 참조변수

- 상속받은 멤버와 자신의 멤버가 **중복되어 서로 구별해야 하는 경우에만** super를 사용하는 것이 좋다.

static 메서드(클래스 메서드)는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super 역시 static 을 사용할 수 없고 인스턴스 메서드에만 사용할 수 있다.

```java
class Point {
  int a = 10;
  int x;
  int y;

  String getLocation() {
    return "x : " + x + ", y : " + y;
  }
}

class Point3D extends Point {
  int a = 20;
  int z;

  String getLocation() { // 오버라이딩
    return super.getLocation() + ", z : " + z; //  슈퍼 클래스의 메서드 호출
  }

  void method() {
    System.out.println("a=" + a);
    System.out.println("this.a=" + this.a);
    System.out.println("super.a=" + super.a);
  }
}

class Supertest {
  public static void main(String[] args) {
    Point3D point3D = new Point3D();
    point3D.method();
  }
}
```

```json
// 실행결과
// a=20
// this.a=20
// super.a=10
```

### super() - 슈퍼 클래스의 생성자

`super()` : 슈퍼 클래스의 생성자를 호출하는데 사용한다.

자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다.

- **슈퍼 클래스 멤버의 초기화 작업** 이 수행되어야 하기 때문에 **하위 클래스의 생성자에서 슈퍼 클래스의 생성자가 호출** 되어야 한다.

**`생성자의 첫 줄`** 에서 **슈퍼 클래스의 생성자를 호출해야 하는 이유** : 하위 클래스의 멤버가 슈퍼 클래스의 멤버를 사용할 수 있으므로 **슈퍼 클래스의 멤버들이 먼저 초기화** 되어 있어야 한다.

Object 클래스를 제외한 모든 클래스들은 **생성자의 첫 줄에 생성자 this() 또는 super()를 호출** 해야 한다. 그렇지 않으면, **컴파일러가 자동적으로** `super();` 를 **생성자의 첫 줄에 삽입한다.**

## package 와 import

### package

`패키지` : **클래스의 묶음**

- `클래스`가 하나의 **물리적인 클래스 파일(.class)** 인 것과 같이
- `패키지`는 **`물리적으로 하나의 디렉토리`**이다.

서로 관련된 클래스들을 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.

클래스의 실제 이름(full name)은 패키지명을 포함한 것이다.

- ex) String 클래스의 full name : java.lang.String
- 그래서 **같은 이름의 클래스** 일 지라도 서로 다른 패키지에 속하면 **패키지 명으로 구별이 가능하다.**

1. 하나의 소스 파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.
2. **모든 클래스는 반드시 하나의 패키지에 속한다.**
3. 패키지는 (.) 을 구분자로 하여 계층구조로 구성할 수 있다.
4. **패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.**

**소스파일에 자신이 속할 패키지를 지정하지 않은 클래스** 는 자동적으로 `이름 없는 패키지(unnamed package)` 에 속하게 된다. **결국 패키지를 지정하지 않은 모든 클래스들은 같은 패키지에 속하는 셈이다.**

### import문

`import` : **컴파일러에게** 소스파일에 사용된 **클래스의 패키지에 대한 정보를 제공하는 것**

- 컴파일 시에 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아낸 다음, **모든 클래스 이름 앞에 패키지 명을 붙여준다.**

- **import문은 프로그램의 성능에 전혀 영향을 미치지 않는다!!! import문을 많이 사용하면 컴파일 시간이 아주 조금 더 걸릴 뿐이다.**

- 클래스 이름을 지정해주는 대신 **`*`** 을 사용하는 것 또한 **실행 시 성능상의 차이는 전혀 없다!!** 컴파일러가 해당 패키지에 일치하는 클래스 이름을 찾는 수고를 더할 뿐이다.

### static import 문

`static import 문` : static 멤버를 호출할 때 **클래스 이름을 생략할 수 있다.**

- **특정 클래스의 static 멤버를 자주 사용할 때 편리하다.**

```java
import static java.lang.Integer.*; // Integer 클래스의 모든 static 메서드
import static java.lang.Math.random; // Math.random()만. 괄호 안붙임.
import static java.lang.System.out; // System.out을 out만으로 참조가능

System.out.println(Math.random());
=>
out.println(random());

import static com.boba.pdf_conversion_api.util.ResponseMessage.UPLOAD_TO_GCS_ERROR;
```

## 제어자(modifier)

`제어자(modifier)` : **클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.**

`접근 제어자` : public, protected, default, private

`그 외` : static, final, abstract, native, transient, synchronized, volatile, strictfp

- 제어자는 클래스, 멤버변수, 메서드에 주로 사용되며, 하나의 대상에 여러 제어자를 조합하여 사용하는 것이 가능하다.
- **단, 접근 제어자는 한번에 네 가지 중 하나만 선택해서 사용할 수 있다.**

### static - 클래스의, 공통적인

`static이 사용될 수 있는 곳` : **멤버변수, 메서드, 초기화 블럭**

- static 이 붙은 멤버변수, 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관한 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.

- 가능하다면 **static 메서드로 하는 것이 인스턴스를 생성하지 않고도 호출이 가능하기 때문에 더 편리하고 속도도 더 빠르다.**

```java
class StaticTest {
  static int width = 200; // 클래스 변수(static 변수)
  static int height = 120; // 클래스 변수(static 변수)

  static {
    // static 변수의 복잡한 초기화 수행
  }

  static int max(int a, int b) { // 클래스 메서드(static 메서드)
    return a > b ? a : b;
  }
}
```

### final - 마지막의, 변경될 수 없는

`final 이 사용될 수 있는 곳` : **클래스, 메서드, 멤버변수, 지역변수**

- `변수` 에 사용되면 값을 변경할 수 없는 `상수`가 된다.
- `메서드` 에 사용되면 `오버라이딩(Overriding) 불가`
- `클래스` 에 사용되면 `다른 클래스의 조상이 될 수 없다`

```java
final class FinalTest { // 조상이 될 수 없는 클래스
  final int SIZE = 10; // 값을 변경할 수 없는 멤버변수(상수)

  final method() { // 오버라이딩 할 수 없는 메서드(변경불가)
    final int LV = SIZE; // 값을 변경할 수 없는 지역변수(상수)
    return SIZE;
  }  
}
```

### abstract - 추상의, 미완성의

`abstract 가 사용될 수 있는 곳` : **클래스, 메서드**

- `메서드` 에 사용되면 선언부만 작성하고 구현부는 작성하지 않은 `추상 메서드` 임을 알린다.
- `클래스` 에 사용되면 클래스 내에 `추상 메서드가 선언` 되어 있음을 알린다.

**추상 클래스** 는 아직 완성되지 않은 메서드가 존재하는 **미완성 설계도** 이므로 **인스턴스를 생성할 수 없다!!**

### 접근 제어자(access modifier)

`접근 제어자(access modifier)` : 멤버 또는 클래스에 사용되어, **해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할**을 한다.

`접근 제어자가 사용될 수 있는 곳` : **클래스, 메서드, 멤버변수, 생성자**

- `private` : **같은 클래스** 내에서만 접근이 가능하다.
- `default` : **같은 패키지** 내에서만 접근이 가능하다.
- `protected` : **같은 패키지** 내에서, 그리고 **다른 패키지의 하위 클래스** 에서 접근이 가능하다.
- `public` : **접근 제한이 없다.**

| 대상             | 사용가능한 접근 제어자                |
| ---------------- | ------------------------------------- |
| **클래스**       | **public, (default)**                 |
| 메서드, 멤버변수 | public, protected, (default), private |
| 지역변수         | 없음                                  |

### 접근 제어자를 이용한 캡슐화(Encapsulation) - 정보 은닉(Information Hiding)

**접근 제어자를 사용하는 이유 => 캡슐화(Encapsulation) - 정보 은닉(Information Hiding)**

- 외부로부터 데이터를 보호하기 위해서

- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

#### Tips

`하나의 소스 파일(.java)` 에는 **public 클래스가 단 하나만 존재** 할 수 있으며, **소스파일의 이름** 은 반드시 **public 클래스의 이름과 같아야 한다.**

### 생성자의 접근 제어자

**생성자에 접근 제어자를 사용함** 으로써 **인스턴스의 생성을 제한** 할 수 있다.

- 생성자의 접근 제어자를 **private** 으로 지정하면, **외부에서** 접근이 불가하므로 인스턴스를 생성할 수 없다. 그래도 **클래스 내부에서는** 인스턴스를 생성할 수 있다.

- **인스턴스를 생성해서 반환** 해주는 **public 메서드** 를 제공, `public` 인 동시에 `static` => 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있다.
  
  - **`정적 팩토리 메서드`**

- 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고, public 메서드를 제공함으로써 **인스턴스의 개수를 제한할 수 있다.**

- 생성자가 private인 클래스는 **다른 클래스의 조상이 될 수 없다.**
  - 자손 클래스의 인스턴스를 생성할 때, **조상 클래스의 생성자(super())를 호출해야 하는데,** 생성자의 접근 제어자가 **private** 이므로 **자손 클래스에서 호출하는 것이 불가능** 하기 때문이다.

- 클래스 앞에 **final** 을 더 추가하여 **상속할 수 없는 클래스** 라는 것을 알리는 것이 좋다.

```java
final class Singleton {
  private static Singleton instance;

  private Singleton() {}

  public static Singleton getInstance() {
    if(instance == null) {
      return instance = new Singleton();
    }
    return instance;
  } 
}

public class SingletonTest {
  public static void main(String[] args) {
    // Singleton singleton = new Singleton(); // Error // Singleton() has privaet access in Singleton

    Singleton instance = Singleton.getInstacne();
  }
}
```

### 제어자(modifier)의 조합

1. **메서드**에 static과 abstract를 함께 사용할 수 없다.
   - `static 메서드`는 **몸통이 있는 메서드**에만 사용할수 있기 때문이다.
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
   - 클래스에 사용되는 final은 확장(상속)을 할 수 없다는 의미
   - abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.

3. abstract 메서드의 접근 제어자가 private일 수 없다.
   - abstract 메서드는 자손 클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문이다.

4. **메서드**에 private과 final을 같이 사용할 필요는 없다.
  - 접근 제어자가 private인 메서드는 오버라이딩 될 수 없기 때문이다. 둘 중 하나만 사용해도 된다.

## 다형성(Polymorphism) - 여러가지 형태를 가질 수 있는 능력 - 사용편의성 

`객체지향 다형성(Polymorphism)` : ***여러가지 형태를 가질 수 있는 능력***
- **`Java 에서는 한 타입의 참조변수로 여러 타입의 객체를 참조 할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.`**

**조상클래스 타입**의 **참조변수**로 **자손클래스**의 **인스턴스**를 참조할 수 있도록 하였다는 것이다.

두 클래스가 서로 상속 관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능하다.

```java
Tv t = new CaptionTv(); // 조상 타입의 참조변수로 자손 인스턴스를 참조 // Up-Casting
CaptionTv c = new CaptionTv();
```

![다형성](https://user-images.githubusercontent.com/56071088/122496831-5eefae00-d027-11eb-8631-c7fdfdb9989a.png)

- 조상 타입의 참조변수로는 자식 타입의 인스턴스 중 **조상 클래스의 멤버들(상속받은 멤버들)만 사용할 수 있다.**

- **둘 다 같은 타입의 인스턴스** 이지만 **참조변수의 타입** 에 따라 **사용할 수 있는 멤버의 개수가 달라진다.**
  - 실제로는 모든 클래스의 최고 조상인 Object 클래스로부터 상속받은 멤버들도 표시해야 하지만 간단히 하기 위해서 위의 그림에서는 생략했다. 


반대로, **자식 타입**의 **참조변수**로 **조상 타입**의 **인스턴스를 참조**하는 것은 **불가능하다!!**

```java
CaptionTv c = new Tv();
```

- **컴파일 에러 발생**

- 실제 인스턴스인 Tv 의 멤버 개수보다 CaptionTv의 **참조변수인 c가 사용할 수 있는 멤버개수가 더 많기 때문이다.**

- 그래서 이를 허용하지 않는다. 

**참조변수**가 **사용할 수 있는 멤버의 개수**는 **인스턴스의 멤버 개수** 보다 **같거나 적어야 한다!!!**

**클래스는 상속을 통해서 확장될 수는 있어도 축소 될 수는 없어서, 조상 인스턴스의 멤버 개수는 자손 인스턴스의 멤버 배수보다 항상 적거나 같다.**

- 모든 참조변수는 **null 또는 4 byte 의 주소값** 이 저장되며, **참조변수의 타입은 참조할 수 있는 객체의 종류와 사용할 수 있는 멤버의 개수를 결정한다.**

### 참조변수의 형변환

참조변수는 **서로 상속관계에 있는 클래스사이**에서만 **형변환이 가능하다.**

- 조상의 조상 타입으로도 형변환이 가능하다. 따라서, **모든 클래스**는 **Object클래스 타입**으로 **형변환이 가능하다.**

1. 자손타입 -> 조상타입 **(Up-Casting)** : **형변환 생략가능** : 작은 자료형 -> 큰 자료형
2. 조상타입 -> 자손타입 **(Down-Casting)** : **형변환 생략불가**

```java
public class CastingTest1 {
  public static void main(String[] args) {
    Car car = null;
    FireEngine fe = new FireEngine();
    FireEngine fe2 = null;

    fe.water();
    car = fe; // car = (Car) fe; 에서 형변환이 생략된 것 // Up-Casting
    // car.water(); // 컴파일 에러, Car 타입의 참조변수로는 water()를 호출할 수 없다. 
    fe2 = (FireEngine) car; // Down-Casting
    fe2.water();
  } 
}

class Car {
  String color;
  int door;

  void drive() {
    System.out.println("drive");
  }

  void stop() {
    System.out.println("stop");
  }
}

class FireEngine extends Car {
  void water() {
    System.out.println("water");
  }
}
```

Car 타입의 참조변수 c를 조상의 Object 타입의 참조변수로 형변환 하는 것은 
- 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않는다.
- 그래서, 형변환을 생략할 수 있도록 한 것이다.

**형변환은 참조변수의 타입을 변환하는 것이다!!**
- **인스턴스를 변환하는 것이 아니다.** 

- **참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.**
- **단지, 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.**

```java
public class CastingTest2 {
  public static void main(String[] args) {
    Car car = new Car();
    Car car2 = null;
    FireEngine fe = null;

    car.drive();
    fe = (FireEngine) car; // Up-Casting // Compile은 OK, 실행 시에 Runtime Error 가 발생.
    // java.lang.ClassCastException: Car
    fe.drive();
    car2 = fe; // Down-Casting
    car2.drive();
  }
}
```

- 참조변수 car 가 참조하는 인스턴스가 Car 타입이다.

- 조상 타입의 인스턴스를 자손 타입의 참조변수로 참조하는 것은 허용되지 않는다.
- 컴파일 시에는 참조변수 간의 타입만 체크하기 때문에 실행 시 에러가 생성될 인스턴스의 타입에 대해서는 전혀 알지 못한다.

**참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.**

### instanceof 연산자

`instanceof` : **참조변수**가 참조하고 있는 **인스턴스의 실제 타입**을 알아보기 위해 사용한다.
- 주로 조건문에 사용된다.
- instanceof 의 **왼쪽에는 참조변수**, **오른쪽에는 타입(클래스 명)**이 피연산자로 위치한다.
- 연산의 결과 : boolean 값인 true, false 중의 하나

- **instanceof 의 결과로 true : 참조변수가 검사한 타입으로 형변환이 가능하다는 의미**
- 값이 null인 참조변수에 대해 instanceof 연산의 결과 : false

```java
public class InstanceofTest {
	public static void main(String args[]) {
		FireEngine fe = new FireEngine();

		if(fe instanceof FireEngine) {
			System.out.println("This is a FireEngine instance.");
		} 

		if(fe instanceof Car) {
			System.out.println("This is a Car instance.");
		} 

		if(fe instanceof Object) {
			System.out.println("This is an Object instance.");
		} 

		System.out.println(fe.getClass().getName()); // 클래스의 이름을 출력
	}
} // class

class Car {}

class FireEngine extends Car {}
```

```json
// 실행결과
// This is a FireEngine instance.
// This is a Car instance.
// This is an Object instance.
// FireEngine
```

- 조상 타입의 instanceof 연산에도 true를 얻는다.

**`어떤 타입에 대한 instanceof의 연산 결과가 true라는 것은 해당 타입으로 형변환이 가능하다는 의미이다!!!`**

### 참조변수와 인스턴스의 연결

조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때
- 조상 타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우 서로 다른 결과를 얻는다.
- super와 this로 구분이 가능

메서드의 경우 조상 클래스의 메서드를 자손 클래스에서 오버라이딩을 한 경우
- 참조변수의 타입에 상관없이 항상 **오버라이딩된 메서드** 가 호출된다.

중복이 아닌 경우는 선택의 여지가 없이 결과가 같다.

**static 메서드는 static 변수처럼 참조변수의 타입에 영향을 받는다.**
- 참조변수의 타입에 영향을 안받는 것은 인스턴스 멤버 뿐이다.
- 그래서, **static 메서드는 반드시 참조변수가 아닌 '클래스명.메서드()'로 호출하자!!**

```java
public class BindingTest3{
	public static void main(String[] args) {
		Parent p = new Child();
		Child  c = new Child();

		System.out.println("p.x = " + p.x);
		p.method();
		System.out.println();
		System.out.println("c.x = " + c.x);
		c.method();
	}
}

class Parent {
	int x = 100;

	void method() {
		System.out.println("Parent Method");
	}
}

class Child extends Parent {
	int x = 200;

	void method() {
		System.out.println("x=" + x);  // this.x와 같다.
		System.out.println("super.x=" + super.x);
		System.out.println("this.x="  + this.x);
	}
}
```

```json
// 실행결과
// p.x = 100
// x = 200
// super.x = 100
// this.x = 200

// c.x = 200
// x = 200
// super.x = 100
// this.x = 200
```

### 매개변수의 다형성

**참조변수의 다형적인 특징**은 **메서드의 매개변수에도 적용된다.**

매개변수가 조상 클래스 타입의 참조변수라는 것은
- **메서드의 매개변수로 조상 클래스의 자손 타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 뜻이다.**

EX1)

```java
void buy(Product p) {
  money = money - p.price;
  bonusPoint = bonusPoint + p.bonusPoint;
}
```

EX2)

```java
class PrintStream {
  ...
  public void print(Object obj) {
    write(String.valueOf(obj)); // valueOf()가 반환한 문자열을 출력한다.
  }

  public static String valueOf(Object obj) {
    return (obj == null) ? "null" : obj.toString(); // 문자열을 반환한다.
  }
}
```

- print(Object obj)는 매개변수로 Object 타입의 변수가 선언되어 있다.
- **Object 클래스는 모든 클래스의 조상** 이므로 이 메서드의 매개변수로 어떤 타입의 인스턴스도 가능하므로, **이 하나의 메서드로 모든 타입의 인스턴스를 처리할 수 있다.**

### 여러 종류의 객체를 배열로 다루기

**조상타입의 참조변수 배열** 을 사용하면, **공통의 조상을 가진 서로 다른 종류의 객체를 배열** 로 묶어서 다룰 수 있다.

- 묶어서 다루고 싶은 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장하면 된다.

```java
Product[] p = new Priduct[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

#### Vector 클래스

`Vector 클래스` : **내부적으로 Object타입의 배열**을 가지고 있어서, **이 배열에 객체를 추가하거나 제거할 수 있다.**
- 배열의 개수를 알아서 관리해주기 때문에 저장할 인스턴스의 개수에 신경 쓰지 않아도 된다.

```Java
public class Vector extends AbstractList implements List, Cloneable, java.io.Serializable {
  
  protected Object elementData[]; 
}
```
Vector 클래스는 이름 때문에 클래스의 기능을 오해할 수 있는데, **단지 동적으로 배열의 크기를 관리해주는 클래스**일 뿐이다.

[Vector 클래스 메서드] 

| 메서드/생성자            | 설명                                                                                                                      |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| Vector()                 | 10개의 객체를 저장할 수 있는 Vector 인스턴스를 생성한다. **10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가한다.** |
| boolean add(Object o)    | Vector에 객체를 추가한다. 추가에 성공하면 true, 실패하면 false                                                            |
| boolean remove(Object o) | Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false                                              |
| boolean inEmpty()        | Vector가 비어있는지 확인한다. 비어있으면 true, 아니면 false                                                               |
| Object get(int index)    | 지정된 위치의(index)의 객첼르 반환한다. **반환 타입이 Object 타입이므로 적절한 타입의 형변환이 필요하다**                 |
| int size()               | Vector에 저장된 객체의 개수를 반환한다.                                                                                   |

```java
public class VectorTest {
  public static void main(String[] args) {
    Vector v = new Vector();
    Product p = new Product();

    v.add(p);
    v.add(p);
    v.remove(p);
    
    if(v.isEmpty()) {
      System.out.println("empty");
    }

    Product p = (Priduct) v.get(0);
  }
}
```

## 추상클래스(abstract class) 

- 클래스 : 설계도
- 추상 클래스 : 미완성 설계도
- 인터페이스 : 기본 설계도

**`추상클래스(abstract class)`** 는 :

1. **단지 미완성 메서드(추상 메서드 : abstract 메서드)를 포함하고 있다는 의미**

2. **추상클래스로 인스턴스는 생성할 수 없다.** 
3. **추상클래스는 상속을 통해서 자손클래스에 의해서만 완성된다.**

4. **새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스로서 중요한 의미를 갖는다.**

추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고는 일반 클래스와 전혀 다르지 않다. **추상 클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.**

-  추상메서드를 포함하고 있지 않은 클래스도 키워드 `abstract` 를 붙여서 추상 클래스로 지정할 수도 있다. 
-  **추상메서드가 없는 완성된 클래스라 할지라도 추상클래스로 지정되면 클래스의 인스턴스를 생성할 수 없다.**

```java
abstract class 클래스이름 {
  ...
}
```

### 추상메서드(abstract method)

**`추상메서드(abstract method)`** : **선언부(메서드의 이름, 매개변수, 리턴 타입)만 있고 구현부는 없는 메서드**
- 즉 설계만 해놓고, 구현은 하지 않았기 때문에 미완성 메서드인 것이다.

- **추상클래스로부터 상속받은 자손클래스는 오버라이딩을 통해  조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다.**
- **만일, 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.** 

```java
/*주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명해준다.*/
abstract 리턴타입 메서드이름();
```

### 추상클래스의 작성

- `추상화` : 클래스간의 공통점을 찾아내어 공통의 조상을 만드는 작업
- `구체화` : 상속을 통해 클래스를 구현, 확장하는 작업

`추상화`는 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것

굳이 abstract 를 붙여서 추상 메서드로 만드는 이유 : 자손 클래스에서 **추상메서드를 반드시 구현하도록 강요**하는 것이다.

## 인터페이스(interface)

클래스 : 설계도

추상 클래스 : 미완성 설계도

`인터페이스(interface)` : 일종의 추상클래스, **기본 설계도**

- 일종의 추상클래스

- **추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.**

- 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.
  - (JDK 1.8 부터 default 메서드와 static 메서드 지원)
- **다른 클래스를 작성하는데 도움 줄 목적으로 작성된다.**

### 인터페이스의 작성

- 키워드로 class 대신 interface 키워드
- interface에도 클래스와 같이 접근제어자로 `public` 또는 `default` 를 사용할 수 있다.

- `모든 멤버변수`는 **public static final** 이어야 하며, 이를 생략할 수 있다.
- `모든 메서드`는 **public abstract**이어야 하며, 이를 생략할 수 있다.
  - **(JDK 1.8부터) static 메서드와 default 메서드는 예외**
  - 생략된 제어자는 컴파일 시에 컴파일러가 자동적으로 추가해준다.

```java
interface 인터페이스이름 {
  public static final 타입 상수이름 = 값;
  public abstract 메서드이름(매개변수목록);
}
```

### 인터페이스의 상속

**인터페이스는 인터페이스로부터만 상속**받을 수 있으며, 클래스와는 달리 **다중상속**, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.

- 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.

```java
interface Movable {
		void move(int x, int y);
}
interface Attackable {
		void attack(Unit u);
}

interface Fightable extends Movable, Attackable {}
```

- Fightable 인터페이스는 정의된 멤버가 하나도 없지만, 조상 인터페이스로부터 상속 받은 두 개의 추상메서드, move(int x, int y)와 attack(Unit u)을 멤버로 갖는다.

### 인터페이스의 구현

- 인터페이스도 추상클래스처럼 **그 자체로는 인스턴스 생성 불가**
- 인터페이스도 자신에 정의된 추상메서드의 **몸통을 만들어주는 클래스를 작성**해야 한다.

- 인터페이스는 구현한다는 의미의 키워드 `implements` 를 사용할 뿐이다.
- 만일 구현하는 인터페이스의 메서드 중 **일부만 구현한다면**, `abstraact`를 붙여서 **추상클래스**로 선언해야 한다.
- 상속과 구현을 동시에 할 수도 있다.

```java
class Fighter implements Fightable {
  public void move(int x, int y) {}
  public void attack(Unit u) {}
}

// 구현하는 인터페이스의 메서드 중 일부만 구현한다면, `abstract`를 붙여서 추상클래스로 선언해야 한다.
abstract class Fighter implements Fightable {
  public void move(int x, int y) {}
}

// 상속과 구현을 동시에 할 수도 있다.
class Fighter extends Unit implements Fightable {
		public void move(int x, int y) {}
		public void attact(Unit u) {}
}
```

### 인터페이스를 이용한 다중상속

- **인터페이스로 다중상속(다중확장)을 하는 경우는 거의 없다.**

- 만일 두 개의 클래스로부터 상속을 받아야 하는 상황이라면,
  - 두 조상 클래스 중에서 비중이 높은 쪽을 선택하고, 다른 한쪽은 멤버로 포함시키는 방식으로 처리한다.
  - 그리고 어느 한쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현하도록 한다.


```java
public class Tv {
  protected boolean power;
  protected int channel;
  protected int volume;

  public void power() { power != power; }
  public void channelUp() { channel++; }
  public void channelDown() { channel--; }
  public void volumeUp() { volume++; }
  public void volumeDown() { volume--; }
}

public class VCR {
		protected int counter;
	
		public void play() {}
		public void stop() {}
		public void reset() {}
}

// VCR 클래스에 정의된 메서드와 일치하는 추상메서드를 갖는 인터페이스를 작성
public interface IVCR {
		public void play();
		public void stop();
		public void reset();

}

public class TVCR extends Tv implements IVCR {
		// 멤버로 포함시킨다.
    VCR vcr = new VCR();

    // 코드를 작성하는 대신 VCR 인스턴스의 메서드를 호출한다.
		public void play() { vcr.play(); }
		public void stop() { vcr.stop(); }
		public void reset() { vcr.reset(); }

}
```

- Tv 클래스와 VCR 두 클래스를 다중 상속 받고 싶은 경우에는 
- 한쪽만 선택하여 상속하고 나머지 한 쪽은 클래스 내에 포함시켜서 내부적으로 인스턴스를 생성해서 사용한다.
  - 비중이 큰 Tv를 상속하고, VCR을 interface인 IVCR로 만들고, 이것을 구현하도록 한다.
  - VCR 클래스 타입의 참조변수를 멤버변수로 선언하여 IVCR 인터페이스의 추상메서드를 구현하는데 사용한다.

### 인터페이스를 이용한 다형성

- `인터페이스` 역시 이를 **구현한 클래스의 조상**
- 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다.
- 인터페이스 타입으로도 형변환 가능하다.

```java
Fightable f = (Fightable) new Fighter();

또는

Fightable f = new Fighter();
```

- `Fightable 타입의 참조변수` 로는 **인터페이스 Fightable에 정의된 멤버들만 호출이 가능하다.**

```java
class Fighter extends Unit implements Fightable {
  
  // 메서드의 매개변수의 타입으로 인터페이스를 사용할 수 있다.
  public void attack(Fightable f) {
    ...
  }
}
```

메서드의 매개변수 타입으로 인터페이스를 사용할 수 있다.

- 인터페이스 타입의 매개변수가 갖는 의미
  - 메서드 호출 시 **해당 인터페이스를 구현한 클래스의 인스턴스**를 매개변수로 제공해야 한다는 것


```java
// 메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것이 가능하다.
Fightable method() {
  ...
  Fightable f = new Fighter();
  return f;

  // -> return new Fighter();
}

@Bean //Spring Container 에 등록 // 스프링 컨테이너가 관리하는 자바 객체 //어플리케이션 컨텍스트(스프링 컨테이너)가 직접 자바 객체를 관리하게끔 하기 위해 달아두는 것
    public MemberService memberService() { //생성자 주입
        System.out.println("call AppConfig.memberService");
        return new MemberServiceImpl(memberRepository());// 구현 객체를 생성//생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.
    } //DI(Dependency Injection) : 의존관계 주입

    @Bean
    public MemoryMemberRepository memberRepository() { //역할(추상화(Interface))에 대한 것과 그에 따른 구현이 한 눈에 보인다.
        System.out.println("call AppConfig.memberRepository");
        return new MemoryMemberRepository();
    }
```

- **`리턴 타입이 인터페이스`** 라는 것의 의미
  - **메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다**는 것을 의미한다.
  
```java
interface Parseable {
	// 구문 분석작업을 수행한다.
	public abstract void parse(String fileName);
}

class ParserManager {
	// 리턴타입이 Parseable 인터페이스이다.
	public static Parseable getParser(String type) {
		if(type.equals("XML")) {
			return new XMLParser();
		} else {
			Parseable p = new HTMLParser();
			return p;
			// return new HTMLParser();
		}
	}
}

class XMLParser implements Parseable {
	public void parse(String fileName) {
		/* 구문 분석작업을 수행하는 코드를 적는다. */
		System.out.println(fileName + "- XML parsing completed.");
	}
}

class HTMLParser implements Parseable {
	public void parse(String fileName) {
		/* 구문 분석작업을 수행하는 코드를 적는다. */
		System.out.println(fileName + "-HTML parsing completed.");
	}
}

class ParserTest {
	public static void main(String args[]) {
		Parseable parser = ParserManager.getParser("XML");
		parser.parse("document.xml");
		parser = ParserManager.getParser("HTML");
		parser.parse("document2.html");
	}
}
```

- 새로운 종류의 파서가 나오면 파서매니저 클래스에 getParser 메서드만 수정하면 된다.
- 이러한 장점은 분산환경 프로그래밍에서 장점이 크다
    - 사용자의 설치된 프로그램 **(클라이언트)을 변경하지 않고 서버측의 변경** 만으로도 새로 개정된 프로그램 사용 가능

### 인터페이스의 장점


- **개발시간을 단축시킬 수 있다.**
    - **인터페이스가 작성되면 이를 사용해서 프로그램 작성 가능**
    
    - 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 **선언부만 알면 된다.**
    - 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하게 되면, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 **양쪽에서 동시에 개발을 진행할 수 있다.**
  
- **표준화가 가능하다.**
    - 프로젝트에 사용되는 **기본 틀을 인터페이스**로 작성한 다음
    
    - 개발자들에게 인터페이스를 구현하여 보다 **일관되고 정형화된 프로그램 개발 가능**

- **서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.**
    - 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 **하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.**


- **독립적인 프로그래밍이 가능하다.**
    - 인터페이스를 이용하면 클래스의 **선언과 구현을 분리 (역할과 구현을 분리)** 시킬 수 있기 때문에 **실제 구현에 독립적인 프로그램 작성 가능**
    
    - 클래스와 클래스간의 직접적인 관계를 **인터페이스를 이용해서 간접적인 관계로 변경**하면, **한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍 가능**

```java
public class RepairableTest{
	public static void main(String[] args) {
		Tank tank = new Tank();
		Dropship dropship = new Dropship();

		Marine marine = new Marine();
		SCV	scv = new SCV();

		scv.repair(tank);	// SCV가 Tank를 수리하도록 한다.
		scv.repair(dropship);
//		scv.repair(marine);	// Error, repair(Repairable) in SCV cannot be aplied to (Marine)
	}
}

class Unit {
	int hitPoint;
	final int MAX_HP;
	
  Unit(int hp) {
		MAX_HP = hp;
	}
	//...
}

class GroundUnit extends Unit {
	GroundUnit(int hp) {
		super(hp);
	}
}

class AirUnit extends Unit {
	AirUnit(int hp) {
		super(hp);
	}
}

interface Repairable {}

class Tank extends GroundUnit implements Repairable {
	Tank() {
		super(150);		// Tank의 HP는 150이다.
		hitPoint = MAX_HP;
	}

	public String toString() {
		return "Tank";
	}
	//...
}

class Dropship extends AirUnit implements Repairable {
	Dropship() {
		super(125);		// Dropship의 HP는 125이다.
		hitPoint = MAX_HP;
	}

	public String toString() {
		return "Dropship";
	}
	//...
}

class Marine extends GroundUnit {
	Marine() {
		super(40);
		hitPoint = MAX_HP;
	}
	//...
}

class SCV extends GroundUnit implements Repairable {
	SCV() {
		super(60);
		hitPoint = MAX_HP;
	}

  // 매개변수 타입이 인터페이스
  // -> 메서드를 호출할 때 인자로 인터페이스를 구현한 클래스의 참조변수를 입력해야 한다.
	void repair(Repairable r) {
		if (r instanceof Unit) {
			Unit u = (Unit)r;
			while(u.hitPoint!=u.MAX_HP) {
				/* Unit의 HP를 증가시킨다. */
				u.hitPoint++;
			}
			System.out.println( u.toString() + "의 수리가 끝났습니다.");
		}
	}	
	//...
}
```

```java
interface Liftable {
		void liftOff();
		void move(int x, int y);
		void stop();
		void land();
}

class LiftableImpl implements Liftable {
		public void liftOff() {}
		public void move(int x, int y) {}
		public void stop() {}
		public void land() {}
}

class Barrack extends Building implements Liftable {
		LiftableImpl l = new LiftableImpl();
		public void liftOff() { l.liftOff(); }
		public void move(int x, int y) { l.move(); }
		public void stop() { l.stop(); }
		public void land() { l.land();}
}

class Factory extends Building implements Liftable {
		LiftableImpl l = new LiftableImpl();
		public void liftOff() { l.liftOff(); }
		public void move(int x, int y) { l.move(); }
		public void stop() { l.stop(); }
		public void land() { l.land();}
}
```

- 이렇게 함으로써 같은 내용의 코드를 배럭 클래스와 팩토리 클래스에서 각기 작성하지 않고 LiftableImpl 클래스 한곳에서 관리 가능
- LiftableImpl 클래스는 후에 다시 재사용 가능

[interface]

```java
// Member에 관한 DB에 접근하는 기능을 정의한 MemberRepository interface
// 앞으로 Member에 관한 DB에 접근하는 기능을 관리하려면 MemberRepository interface를 구현하면 된다.  
public interface MemberRepository {

    void save(Member member);

    Member findById(Long memberId);
}

// Member 에 관한 Service를 담당하는 MemberService
// 앞으로 Member에 관한 Service를 담당하는 기능을 관리하려면 MemberService interface를 구현하면 된다.
public interface MemberService {
    void join(Member member); 

    Member findMember(Long memberId);
}

public interface DiscountPolicy {
    /**
     * @return 할인 대상 금액
     */
    int discount(Member member, int price);

}
```

- 인터페이스의 장점 - 2. 표준화가 가능하다

```java
@Component
public class MemberServiceImpl implements MemberService{//Interface 의 구현체가 하나일 경우에 Impl 이라고 붙여주는 관례
    //"DIP 적용" : AppConfig 를 사용함으로써 구현체가 아닌 추상화(Interface)에만 의존하도록 만들었다.
    private final MemberRepository memberRepository;

    //@Autowired 는 의존관계를 자동으로 주입해준다. 의존 관계 자동 주입
    //ac.getBean(MemberRepository.class) 이런 식으로 동작한다고 보면 된다.
    @Autowired 
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}

@Component
public class MemoryMemberRepository implements MemberRepository{

    private static Map<Long, Member> store = new HashMap<>(); //여러 곳에서 store 변수를 접근하면 동시성 이슈가 발생 가능
    // 실무에서는 동시성 이슈 때문에 ConcurrentHashMap 을 사용한다.

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findById(Long memberId) {
        return store.get(memberId);
    }
}

@Component
public class FixDiscountPolicy implements DiscountPolicy{

    private int discountFixAmount = 1000;
    @Override
    public int discount(Member member, int price) {
        if(member.getGrade() == Grade.VIP) 
            return discountFixAmount;
        else
            return 0;
    }
}

@Component
@MainDiscountPolicy
public class RateDiscountPolicy implements DiscountPolicy{

    private int discountPercent = 10;

    @Override
    public int discount(Member member, int price) {
        if(member.getGrade() == Grade.VIP)
            return price * discountPercent / 100;
        else
            return 0;
    }
}
```

- 인터페이스의 장점 
  - 1번 장점. 서로 독립적인 프로그래밍 가능(한 클래스의 변경이 다른 클래스의 변경에 영향을 미치지 않는다.) 
  
  - 3번 장점. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.(인터페이스를 구현하도록 함으로써 클래스들에게 관계를 맺어줄 수 있다.)
  
  - 4번 장점. 개발시간 단축(인터페이스를 구현하는 클래스가 구현될 때까지 기다리지 않고 서로 독립적인 개발 가능) 
  

### 인터페이스의 이해

인터페이스를 이해하기 위해서는 다음의 2가지 사항을 반드시 염두해두자.
- **클래스를 사용하는 쪽** `(Client)` 과 **클래스를 제공하는 쪽** `(Server)` 가 있다.
- **메서드를 호출하는 쪽** `(Client)` 에서는 **사용하려는 메서드(Server)** 의 **선언부** 만 알면 된다. **(내용은 몰라도 된다)**

![interface](https://user-images.githubusercontent.com/56071088/122630951-8a939680-d102-11eb-8237-d0877dd096cc.png)

EX1)

```java
interface I {
  public abstract void methodB();
}

class B implements I {
  public void methodB() {
    System.out.println("method b");
  }
}

class A {
  // class A 는 class B 가 어떻게 구현되는지 몰라도 된다.
  // 단지 interface만 알고 interface 메서드의 선언부만 알면된다.
  public void methodA(I i) { 
    i.methodB(); 
  } 
} 
```

- 인터페이스를 매개체로 해서 클래스 A 가 `인터페이스`를 통해 **클래스 B의 메서드에 접근**하게 한다.
- 클래스 B에 변경사항이 생기거나 클래스 B와 같은 기능의 다른 클래스로 대체 되어도 **클래스 A는 전혀 영향을 받지 않도록 하는 것이 가능하다.**
- 클래스 A 와 B 는 `A - B` 의 직접적인 관계에서 `A - I - B` 의 **간접적인 관계**로 바뀐 것이다.

EX2-1)

```java
class A {
  void autoPlay(I i) {
    i.play();
  }
}

interface I {
  public abstract void play();
}

class B implements I {
  public void play() {
    System.out.println("play in B class");
  }
}

class C implements I {
  public void play() {
    System.out.println("play in C class");
  }
}

public class InterfaceTest2 {
  public static void main(String[] args) {
    A a = new A();
    a.autoPlay(new B()); // void autoPlay(I i)호출
    a.autoPlay(new C()); // void autoPlay(I i)호출
  }
}
```

- interface를 매개변수로 두어, 메서드를 호출할 때, interface를 구현한 클래스의 인스턴스를 **동적으로 제공받아야 한다.**
- `클래스 Thread` 의 생성자인 `Thread(Runnable targer)`이 이런 방식으로 되어 있다.  


EX2-2)

[SoC - 관심사의 분리 - 역할과 구현을 분리]

```java

//애플리케이션 설정 정보, 구성 정보를 담당하는 파일이라는 뜻
//애플리케이션에 대한 환경 구성을 한다. 
//DI 컨테이너
//공연을 구성하고, 담당 배우를 섭외하고, 역할에 맞는 배우를 지정하는 책임을 담당하는 별도의 "공연 기획자"와 같다.
//애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스이다.
public class AppConfig { 

    @Bean     
    public MemberService memberService() { //생성자 주입
        System.out.println("call AppConfig.memberService");
        return new MemberServiceImpl(memberRepository());// 구현 객체를 생성//생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.
    } //DI(Dependency Injection) : 의존관계 주입

    @Bean
    public MemoryMemberRepository memberRepository() { 
        System.out.println("call AppConfig.memberRepository");
        return new MemoryMemberRepository();
    }

    @Bean
    public OrderService orderService() {
        System.out.println("call AppConfig.orderService");
        return new OrderServiceImpl(memberRepository(), discountPolicy()); 
//        return null;
    }
    //AppConfig 를 보면 역할과 구현 클래스가 한눈에 들어온다.
    // 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.
    @Bean
    public DiscountPolicy discountPolicy() {
        //return new FixDiscountPolicy();
        return new RateDiscountPolicy();
    }
}
```

- 애플리케이션의 설정 정보(AppConfig)이다.
- 애플리케이션이 실행될 때, **동적으로** 애플리케이션의 전체 동작 방식을 구성(config)하기 위해 구현 객체를 생성하고 연결해준다.

EX3)

```java
interface I {
  public abstract void methodB();
}

class B implements I {
  public void methodB() {
    System.out.println("methodB in B class");
  }
  public String toString() { return "class B"; }
}

class InstanceManager {
  public static I getInstance() {
    return new B(); // 다른 인스턴스로 바꾸려면 여기만 변경하면 됨.
  }
}

class A {
  void methodA() {
    // 제 3의 클래스의 메서드를 통해서 인터페이스 I를 구현한 클래스의 인스턴스를 얻는다.
    I i = InstanceManager.getInstance();
    i.methodB();
    System.out.println(i.toString()); // i로 Object클래스의 메서드 호출가능
  }
}

public class InterfaceTest3 {
  public static void main(String[] args) {
    A a = new A();
    a.methodA();
  }
}
```

- **제 3의 클래스를 통해 제공받을 수도 있다.**
  - **JDBC의 DriveManager 클래스**가 이런 방식으로 되어 있다.

### 디폴트 메서드와 static 메서드

원래는 인터페이스에 추상 메서드만 선언할 수 있었는데, JDK 1.8부터 디폴트 메서드와 static 메서드도 추가할 수 있게 되었다.

**`statc 메서드`**

- static메서드는 **인스턴스와 관계가 없는 독립적인 메서드** 이기 때문에 이전부터 추가하지 못할 이유가 없었다.

- 하지만 규칙에 예외를 두지 않기 위해 금지, 따라서 java.util.Collection 인터페이스에 관련 statice 메서드들은 Collections라는 클래스에 들어가게 되었다.
  - 인터페이스의 static 메서드 역시 항상 public이며 생략 가능

**`디폴트 메서드`**

아무리 interface 설계를 잘해도 언젠가는 변경은 발생하기 마련이고, 변경이 발생한다면, inteface를 구현한 클래스들을 모두 변경시켜야 한다. 이러한 이유로 JDK의 설계자들은 고심 끝에 `디폴트 메서드(default method)`라는 것을 고안해 내었다.

- 추상메서드의 **기본적인 구현을 제공하는 메서드**

- 추상메서드가 아니기 때문에 **디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.**

- 앞에 키워드 `default`를 붙이며, 추상 메서드와 달리 **일반 메서드처럼 몸통{}** 이 있어야 한다. 
- 디폴트 메서드 역시 접근 제어자가 `public` 이며, **생략 가능하다.**

```java
interface InterfaceTest {
  void method();
  default void method2 { ... }
}
```

새로 추가된 디폴트 메서드가 **기존의 메서드와 이름이 중복되어 충돌하는 경우**가 발생할 때

1. 여러 인터페이스의 디폴트 메서드 간의 충돌
     - 인터페이스를 **구현한 클래스에서 디폴트 메서드를 오버라이딩**해야 한다.


2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
     - **조상 클래스의 메서드가 상속**되고, 디폴트 메서드는 무시된다.  

### 인터페이스들의 메소드 중복

[참고] 아래의 코드는 https://songhayoung.github.io/2020/08/11/Java/duplicateMethodInterface/#%EB%8B%A4%EC%A4%91-%ED%99%95%EC%9E%A5%EC%97%90%EC%84%9C-%EB%AA%85%EC%8B%9C%EC%A0%81-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%98%B8%EC%B6%9C 해당 링크의 코드를 참고하여 작성함을 알린다. 

인터페이스들간의 메소드가 중복될 경우 어떻게 처리 될지가 궁금하여 테스트해 보았다. 우선적으로 default가 아닌 인터페이스 메소드는 제외했다. default가 아니라면 상속을 받은 뒤에 구현을 해야함은 변함이 없기 때문이다.

#### 1. 하나는 default 메소드이고 하나는 virtual 메소드이다.

```java
public interface SomeInterface1 {
    default void someMethod() {
        System.out.println("Interface1 Method");
    }
}

public interface SomeInterface2 {
    void someMethod();
}

public class SomeClass implements SomeInterface1, SomeInterface2{

}
```

- SomeInterface2의 메소드를 구현하라는 경고가 표시된다.
- 추상메서드(abstract method)가 default 메서드보다 우선된다.

#### 2. 둘 다 default 메소드이다.

```java
public interface SomeInterface1 {
    default void someMethod() {
        System.out.println("Interface1 Method");
    }
}

public interface SomeInterface2 {
    default void someMethod() {
        System.out.println("Interface2 Method");
    }
}

public class SomeClass implements SomeInterface1, SomeInterface2{

}
```

- conflict 경고가 표시된다. 
- SomeClass에서 **두 인터페이스 중 하나**의 인터페이스의 메서드를 **오버라이딩**해야 한다.

#### 3.인터페이스가 상속관계에 존재하고 상위 인터페이스는 default이고 하위 인터페이스는 virtual이다.

```java
public interface SomeInterface1 {
    default void someMethod() {
        System.out.println("Interface1 Method");
    }
}

public interface SomeInheritanceInterface extends SomeInterface1 {
    void someMethod();
}

public class SomeClass implements SomeInheritanceInterface{

}
```

- SomeInheritanceInterface의 메소드를 구현하라는 경고가 표시된다.
- 추상 메서드가 우선되는 것인가?


#### 4. 인터페이스가 상속관계에 존재하고 모두 default 메소드이다.

```java
public interface SomeInterface1 {
    default void someMethod() {
        System.out.println("Interface1 Method");
    }
}

public interface SomeInheritanceInterface extends SomeInterface1 {
    default void someMethod() {
        System.out.println("SomeInheritanceInterface Method");
    }
}

public class SomeClass implements SomeInheritanceInterface{

}
```

- **오버라이드** 되었기 때문에 **하위 인터페이스의 default 메소드**가 수행된다.

#### 다중 상속(다중 확장)에서 명시적 인터페이스 메소드 호출

2와 같은 경우에서 두 인터페이스의 default 메소드를 호출하고 싶다면 다음과 같이 수행하면 된다.

- `인터페이스명.super.메서드명()` 으로 어느 interface의 메서드를 사용할지 인터페이스명으로 명시해줘야 한다.

```java
public class SomeClass implements SomeInterface1, SomeInterface2{
    @Override
    public void someMethod() {
        SomeInterface1.super.someMethod();
        SomeInterface2.super.someMethod();
    }
}
```

## 내부 클래스(inner class) 

`내부 클래스(inner class)` : **클래스 내부에 선언된 클래스** 

- 클래스 내에 선언된다는 점을 제외하고는 일반적인 클래스와 다르지 않다.
- 클래스 내부에 다른 클래스를 선언하는 이유는 두 클래스가 서로 밀접한 관계가 있다는 것이다.

**내부 클래스의 장점**

1. 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
2. 코드의 복잡성을 줄일 수 있다.(캡슐화)

### 내부 클래스의 종류와 특징

내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언 가능하다.

내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다.

- `인스턴스 클래스`
  - 외부 클래스의 멤버변수 선언위치에 선언
  - 외부 클래스의 인스턴스멤버 처럼 다루어진다.
  - 주로 **외부 클래스의 인스턴스 멤버들과 관련된 작업**에 사용될 목적으로 선언

- `스태틱 클래스`
  - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static 멤버처럼 다루어진다.
  - 주로 **외부 클래스의 static 멤버, 특히 static 메서드**에서 사용될 목적으로 선언

- `지역 클래스`
  - 외부 클래스의 메서드나 초기화블럭 안에 선언한다.
  - **선언된 영역 내부에서만 사용**될 수 있다.

- `익명 클래스`
  - 클래스의 선언과 객체의 생성을 동시에 하는 **이름없는 클래스(일회용)**

내부 클래스도 클래스이기 때문에 abstract나 final과 같은 제어자를 사용할 수 있고, 멤버변수들처럼 private, protected 등의 접근 제어자도 사용 가능하다.

**내부 클래스 중에서 static 클래스(StaticInner)에서만 static 멤버를 정의할 수 있다.**
- 내부 클래스에서 static 변수를 선언해야 한다면 static클래스로 선언해야 한다.
- 다만, static 과 final 이 동시에 붙은 변수는 상수(constant)이므로 모든 내부 클래스에서 선언 가능하다.

```java
class InnerEx1 { 
  class InstanceInner {
    int iv = 100; 
    // 에러! static변수를 선언할 수 없다.
//  static int cv = 100;             
    final static int CONST = 100;   // final static은 상수이므로 허용한다. 
  } 

  static class StaticInner { 
    int iv = 200; 
    // static클래스만 static멤버를 정의할 수 있다.
    static int cv = 200; 
  } 

  void myMethod() { 
    class LocalInner { 
      int iv = 300; 
      // 에러! static변수를 선언할 수 없다.
//      static int cv = 300; 
      final static int CONST = 300; // final static은 상수이므로 허용 
    } 
  } 

  public static void main(String args[]) { 
    System.out.println(InstanceInner.CONST); 
    System.out.println(StaticInner.cv); 
  } 
} 
```

```java
class InnerEx2 {
	class InstanceInner {}
	static class StaticInner {}

	// 인스턴스멤버 간에는 서로 직접 접근이 가능하다.
	InstanceInner iv = new InstanceInner();
	// static 멤버 간에는 서로 직접 접근이 가능하다.
	static StaticInner cv = new StaticInner();

	static void staticMethod() {
        // static멤버는 인스턴스멤버에 직접 접근할 수 없다.
//		InstanceInner obj1 = new InstanceInner();	
		StaticInner obj2 = new StaticInner();

        //	굳이 접근하려면 아래와 같이 객체를 생성해야 한다.
        //	인스턴스클래스는 외부 클래스를 먼저 생성해야만 생성할 수 있다.
		InnerEx2 outer = new InnerEx2();
		InstanceInner obj1 = outer.new InstanceInner();
	}

	void instanceMethod() {
        // 인스턴스메서드에서는 인스턴스멤버와 static멤버 모두 접근 가능하다.
		InstanceInner obj1 = new InstanceInner();
		StaticInner obj2 = new StaticInner();
		// 메서드 내에 지역적으로 선언된 내부 클래스는 외부에서 접근할 수 없다.
//		LocalInner lv = new LocalInner();
	}

	void myMethod() {
		class LocalInner {}
		LocalInner lv = new LocalInner();
	}
}
```

```java
class InnerEx3 {
	private int outerIv = 0;
	static int outerCv = 0;

	class InstanceInner {
		int iiv  = outerIv;  // 외부 클래스의 private멤버도 접근가능하다.
		int iiv2 = outerCv;
	}

	static class StaticInner {
// 스태틱 클래스는 외부 클래스의 인스턴스멤버에 접근할 수 없다.
//		int siv = outerIv;
		static int scv = outerCv;
	}

	void myMethod() {
		int lv = 0;
		final int LV = 0;  // JDK1.8부터 final 생략 가능
	
		class LocalInner {
			int liv = outerIv;
			int liv2 = outerCv;
//	외부 클래스의 지역변수는 final이 붙은 변수(상수)만 접근가능하다.
//			int liv3 = lv;	// 에러!!!(JDK1.8부터 에러 아님)
			int liv4 = LV;	// OK
		}
	}
}
```

- `인스턴스 클래스`는 외부 클래스의 인스턴스 멤버이기 때문에 인스턴스 변수, static 변수 모두 사용 가능하다.
  - 외부 클래스의 인스턴스 변수(outerIv)의 접근제어자가 **private 일지라도 접근 가능하다.**

- `스태틱 클래스`는 외부 클래스의 스태틱 멤버이기 때문에 **외부 클래스의 인스턴스 멤버 사용 불가**
  - 스태틱 멤버만 사용 가능
    
- `지역 클래스`는 외부 클래스의 인스턴스 멤버와 static 멤버를 모두 사용 가능
  
  - 지역 클래스가 포함된 메서드에 정의된 지역변수도 사용 가능
  - 단 final만 붙은 지역변수만 접근 가능
      - **그 이유는 메서드가 수행을 마쳐서 지역변수가 소멸된 시점에도, 지역 클래스의 인스턴스가 소멸된 지역변수를 참조하려는 경우가 발생할 수 있기 때문이다.**
      - **JDK 1.8 이후** 지역 클래스에서 접근하는 **지역 변수 앞에 final 생략 가능하다.**
          - 하지만 변수의 값이 바뀌는 문장이 있으면 컴파일 에러

```java
import java.util.*;

public class LocalInnerTest {
    public Object func() {
        final ArrayList<String> list = new ArrayList<String>(10);
        list.add("hello ");

        class LocalInner {
            public String toString() {
                StringBuilder sb = new StringBuilder();
                Iterator it = list.iterator();
                while (it.hasNext()) {
                  sb.append(it.next());
                }
                list.add("hi ");
                return sb.toString();
            }
        };

        return new LocalInner();
    }

    public static void main(String[] args) {
        LocalInnerTest test = new LocalInnerTest();
        
        Object obj = test.func();
        
        for (int i = 0; i < 5 ; ++i) {
            System.out.println( obj  );
        }
    }
} 
```
```java
LocalInnerTest test = new LocalInnerTest();
        
Object obj = test.func();
        
for (int i = 0; i < 5 ; ++i) {
  System.out.println( obj  );
}
```

- 이 부분에서 func()메서드는 종료되었지만 지역클래스에 대한 참조는 살아있다.

- obj가 참조하고 있다. 이때 list역시 살아있게 된다. 

- 지역클래스에서 참조를 하고 있기 때문이다. 

- obj -> new LocalInner() -> list 요렇게 서로 참조하고 있기 때문에 가비지 컬렉션 대상이 되지 않는다.

```java
final ArrayList<String> list = new ArrayList<String>(10);
```

- 여기서 문제는 list가 사라진다는 것인데, (func()가 종료.) 

- 그러나 **list가 final이면 상수**라서 **constant pool에 따로 가지고 있어서** 사라져도 괜찮다!!

- 그래서 아무런 문제없이 잘 실행되는 것이다.

- **즉, final이 아니었다면 그 값을 알 수 없었다. final이면 상수라서 constant pool에 따로 저장하고 있기 때문에 그렇다!!!.**

정리하자면,

- **지역변수를 final로 지정하면 JVM constant pool에서 따로 변수를 관리한다.**

- 따라서 지역클래스를 포함하고 있는 메서드와 메서드 안에 있는 final 지역변수는 생명주기가 달라진다. 
  - 이 이유로 메서드가 가비지컬렉션에 반납되어도 메서드 안의 
final 지역변수는 constant pool에서 계속 보관하고 있기 때문에 이를 참조하고 있는 
지역 클래스의 인스턴스는 문제없이 동작할 수 있다. 
  - 즉, 생명주기가 달라지면 동작의 안전성을 보장하지 못하므로 지역(익명)클래스에서 외부의 변수를
사용하기 위해서는 final로 지정된 변수를 사용하도록 하고 있다.

[참고] https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=javaking75&logNo=140178355095 , https://cafe.naver.com/javachobostudy?iframe_url_utf8=%2FArticleRead.nhn%3Fclubid%3D10286641%26articleid%3D18955

```java
class Outer {
	class InstanceInner {
		int iv=100;
	}
	static class StaticInner {
		int iv=200;
		static int cv=300;
	}

	void myMethod() {
		class LocalInner {
			int iv=400;
		}
	}
}

class InnerEx4 {
	public static void main(String[] args) {
		// 인스턴스클래스의 인스턴스를 생성하려면
		// 외부 클래스의 인스턴스를 먼저 생성해야 한다.
		Outer oc = new Outer();
		Outer.InstanceInner ii = oc.new InstanceInner();

		System.out.println("ii.iv : "+ ii.iv);
		System.out.println("Outer.StaticInner.cv : " + Outer.StaticInner.cv);

	     // 스태틱 내부 클래스의 인스턴스는 외부 클래스를 먼저 생성하지 않아도 된다.
		Outer.StaticInner si = new Outer.StaticInner();
		System.out.println("si.iv : "+ si.iv);
	}
}
```

위 코드를 컴파일 시 생성되는 클래스 파일은 다음과 같다.

```json
InnerEx4.class
Outer.class
Outer$InstanceInner.class
Outer$StaticInner.class
Outer$LocalInner.class
```

컴파일 했을 때 생성되는 파일명은 `외부클래스명$내부 클래스명.class` 형식이다.




















