# item4 인스턴스화를 막으려거든 private생성자를 사용하라

`정적 메서드와 정적 필드만을 담은 클래스`를 만들 때가 있다. (객체 지향적인 코드가 아니어서 별로지만, 그 나름의 쓰임새가 분명히 있는 형태이다.)
- `java.lang.Math` : 기본 타입 값 
- `java.util.Arrays`  : 배열 관련된 메서드들을 모아 놓을 수 있다.
- `java.util.Collections` : 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩토리 메서드)를 모아놓을 수 있다,
  - Java 8 부터는 이런 메서드를 interface에 넣을 수 있다.(static 메서드, default 메서드)
- `final 클래스`와 관련한 메서드들을 모아놓을 때도 사용한다.
  - final 클래스를 상속해서 하위 클래스에 메서드를 넣는 건 불가능하기 때문이다.

`정적 멤버만 담은 유틸리티 클래스(Utility Class)`는 인스턴스로 만들어 쓰려고 설계한 게 아니다.
- **하지만, Compiler가 자동적으로 기본 생성자(default constructor)를 만들어준다.** 
- 사용자는 이 생성자가 자동 생성된 것인지 아닌지 구분하지 못한다.

**추상 클래스(abstract class)를 만드는 것으로는 인스턴스화를 막을 수 없다.**
- **상속을 받아서 하위 클래스**를 만들어 **인스턴스화** 할 수 있기 때문이다.
- 오히려, 추상 클래스를 본 사용자가 상속을 받아서 쓰라는 것으로 오해할 수도 있다.

### 해결방법

Compiler가 기본 생성자를 만드는 경우는 명시된 생성자가 없을 때 뿐이다.

**따라서, private생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다!!** 

**[인스턴스를 만들 수 없는 유틸리티 클래스]**

```java
public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다.(인스턴스화 방지용)
    private UtilityClass {
        throw new AsserionError();
    }

    ... //나머지 코드 생략
}
```

- 명시적 생성자가 private이니 클래스 바깥에서 접근할 수 없다.
- **꼭 AsserionError를 던질 필요는 없지만, 클래스 안에서 실수로라도 생성자를 호출하지 않도록 도와준다.**
- **이 코드는 어떠한 환경에서도 클래스가 인스턴스화되는 것을 막아준다.**
- 생성자가 있는데 호출할 수 없으니, 주석을 달아서 명시해주는 센스를 보여주자.
- 이러한 방식은 상속(inheritance)를 막아주기도 한다.
  - 생성자가 private이면 하위 클래스가 instance를 생성할 때, super()로 상위클래스의 생성자를 호출하는데, 상위 클래스의 생성자가 private으로 막혀있기 때문이다.